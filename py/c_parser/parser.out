Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> ext_declarations fundefs instructions
Rule 2     ext_declarations -> declarations
Rule 3     declarations -> declarations declaration
Rule 4     declarations -> declaration
Rule 5     declarations -> <empty>
Rule 6     declaration -> fundefs
Rule 7     declaration -> TYPE inits ;
Rule 8     declaration -> error ;
Rule 9     inits -> inits , init
Rule 10    inits -> init
Rule 11    init -> ID = expression
Rule 12    instructions -> instructions instruction
Rule 13    instructions -> instruction
Rule 14    instruction -> labeled_instr
Rule 15    instruction -> assignment ;
Rule 16    instruction -> declaration
Rule 17    instruction -> choice_instr
Rule 18    instruction -> while_instr
Rule 19    instruction -> for_instr
Rule 20    instruction -> return_instr
Rule 21    instruction -> break_instr
Rule 22    instruction -> continue_instr
Rule 23    instruction -> compound_instr
Rule 24    instruction -> statement
Rule 25    instruction -> expression ;
Rule 26    statement -> ID ( expr_list_or_empty ) ;
Rule 27    labeled_instr -> ID : instruction
Rule 28    assignment -> ID = expression
Rule 29    assignment -> ID = error ;
Rule 30    choice_instr -> IF ( condition ) instruction
Rule 31    choice_instr -> IF ( condition ) instruction ELSE instruction
Rule 32    choice_instr -> IF ( error ) instruction
Rule 33    choice_instr -> IF ( error ) instruction ELSE instruction
Rule 34    while_instr -> WHILE ( condition ) instruction
Rule 35    for_instr -> FOR ( instruction expression ; assignment ) instruction
Rule 36    for_instr -> FOR ( error ) instruction
Rule 37    while_instr -> WHILE ( error ) instruction
Rule 38    return_instr -> RETURN expression ;
Rule 39    continue_instr -> CONTINUE ;
Rule 40    break_instr -> BREAK ;
Rule 41    compound_instr -> { declarations instructions }
Rule 42    compound_instr -> { }
Rule 43    condition -> expression
Rule 44    const -> INTEGER
Rule 45    const -> FLOAT
Rule 46    const -> STRING
Rule 47    expression -> const
Rule 48    expression -> ID
Rule 49    expression -> ( expression )
Rule 50    expression -> ( error )
Rule 51    expression -> ID ( expr_list_or_empty )
Rule 52    expression -> ID ( error )
Rule 53    expression -> expression + expression
Rule 54    expression -> expression - expression
Rule 55    expression -> expression * expression
Rule 56    expression -> expression / expression
Rule 57    expression -> expression % expression
Rule 58    expression -> expression | expression
Rule 59    expression -> expression & expression
Rule 60    expression -> expression ^ expression
Rule 61    expression -> expression AND expression
Rule 62    expression -> expression OR expression
Rule 63    expression -> expression SHL expression
Rule 64    expression -> expression SHR expression
Rule 65    expression -> expression EQ expression
Rule 66    expression -> expression NEQ expression
Rule 67    expression -> expression > expression
Rule 68    expression -> expression < expression
Rule 69    expression -> expression LE expression
Rule 70    expression -> expression GE expression
Rule 71    expr_list_or_empty -> expr_list
Rule 72    expr_list_or_empty -> <empty>
Rule 73    expr_list -> expr_list , expression
Rule 74    expr_list -> expression
Rule 75    fundefs -> fundefs fundef
Rule 76    fundefs -> fundef
Rule 77    fundefs -> <empty>
Rule 78    fundef -> TYPE ID ( args_list_or_empty ) compound_instr
Rule 79    args_list_or_empty -> args_list
Rule 80    args_list_or_empty -> <empty>
Rule 81    args_list -> args_list , arg
Rule 82    args_list -> arg
Rule 83    arg -> TYPE ID

Terminals, with rules where they appear

%                    : 57
&                    : 59
(                    : 26 30 31 32 33 34 35 36 37 49 50 51 52 78
)                    : 26 30 31 32 33 34 35 36 37 49 50 51 52 78
*                    : 55
+                    : 53
,                    : 9 73 81
-                    : 54
/                    : 56
:                    : 27
;                    : 7 8 15 25 26 29 35 38 39 40
<                    : 68
=                    : 11 28 29
>                    : 67
AND                  : 61
BREAK                : 40
CONTINUE             : 39
ELSE                 : 31 33
EQ                   : 65
FLOAT                : 45
FOR                  : 35 36
GE                   : 70
ID                   : 11 26 27 28 29 48 51 52 78 83
IF                   : 30 31 32 33
INTEGER              : 44
LE                   : 69
NEQ                  : 66
OR                   : 62
RETURN               : 38
SHL                  : 63
SHR                  : 64
STRING               : 46
TYPE                 : 7 78 83
WHILE                : 34 37
^                    : 60
error                : 8 29 32 33 36 37 50 52
{                    : 41 42
|                    : 58
}                    : 41 42

Nonterminals, with rules where they appear

arg                  : 81 82
args_list            : 79 81
args_list_or_empty   : 78
assignment           : 15 35
break_instr          : 21
choice_instr         : 17
compound_instr       : 23 78
condition            : 30 31 34
const                : 47
continue_instr       : 22
declaration          : 3 4 16
declarations         : 2 3 41
expr_list            : 71 73
expr_list_or_empty   : 26 51
expression           : 11 25 28 35 38 43 49 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 73 74
ext_declarations     : 1
for_instr            : 19
fundef               : 75 76
fundefs              : 1 6 75
init                 : 9 10
inits                : 7 9
instruction          : 12 13 27 30 31 31 32 33 33 34 35 35 36 37
instructions         : 1 12 41
labeled_instr        : 14
program              : 0
return_instr         : 20
statement            : 24
while_instr          : 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . ext_declarations fundefs instructions
    (2) ext_declarations -> . declarations
    (3) declarations -> . declarations declaration
    (4) declarations -> . declaration
    (5) declarations -> .
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! reduce/reduce conflict for ID resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for IF resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for FOR resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for { resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for ( resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for INTEGER resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for STRING resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for $end resolved using rule 5 (declarations -> .)
    ID              reduce using rule 5 (declarations -> .)
    IF              reduce using rule 5 (declarations -> .)
    WHILE           reduce using rule 5 (declarations -> .)
    FOR             reduce using rule 5 (declarations -> .)
    RETURN          reduce using rule 5 (declarations -> .)
    BREAK           reduce using rule 5 (declarations -> .)
    CONTINUE        reduce using rule 5 (declarations -> .)
    {               reduce using rule 5 (declarations -> .)
    (               reduce using rule 5 (declarations -> .)
    INTEGER         reduce using rule 5 (declarations -> .)
    FLOAT           reduce using rule 5 (declarations -> .)
    STRING          reduce using rule 5 (declarations -> .)
    $end            reduce using rule 5 (declarations -> .)
    TYPE            shift and go to state 6
    error           shift and go to state 7

  ! TYPE            [ reduce using rule 5 (declarations -> .) ]
  ! error           [ reduce using rule 5 (declarations -> .) ]
  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]
  ! $end            [ reduce using rule 77 (fundefs -> .) ]

    program                        shift and go to state 1
    ext_declarations               shift and go to state 2
    fundefs                        shift and go to state 3
    declarations                   shift and go to state 4
    declaration                    shift and go to state 5
    fundef                         shift and go to state 8

state 1

    (0) S' -> program .



state 2

    (1) program -> ext_declarations . fundefs instructions
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
    ID              reduce using rule 77 (fundefs -> .)
    error           reduce using rule 77 (fundefs -> .)
    IF              reduce using rule 77 (fundefs -> .)
    WHILE           reduce using rule 77 (fundefs -> .)
    FOR             reduce using rule 77 (fundefs -> .)
    RETURN          reduce using rule 77 (fundefs -> .)
    BREAK           reduce using rule 77 (fundefs -> .)
    CONTINUE        reduce using rule 77 (fundefs -> .)
    {               reduce using rule 77 (fundefs -> .)
    (               reduce using rule 77 (fundefs -> .)
    INTEGER         reduce using rule 77 (fundefs -> .)
    FLOAT           reduce using rule 77 (fundefs -> .)
    STRING          reduce using rule 77 (fundefs -> .)
    $end            reduce using rule 77 (fundefs -> .)
    TYPE            shift and go to state 10

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]

    fundefs                        shift and go to state 9
    fundef                         shift and go to state 8

state 3

    (6) declaration -> fundefs .
    (75) fundefs -> fundefs . fundef
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
    error           reduce using rule 6 (declaration -> fundefs .)
    ID              reduce using rule 6 (declaration -> fundefs .)
    IF              reduce using rule 6 (declaration -> fundefs .)
    WHILE           reduce using rule 6 (declaration -> fundefs .)
    FOR             reduce using rule 6 (declaration -> fundefs .)
    RETURN          reduce using rule 6 (declaration -> fundefs .)
    BREAK           reduce using rule 6 (declaration -> fundefs .)
    CONTINUE        reduce using rule 6 (declaration -> fundefs .)
    {               reduce using rule 6 (declaration -> fundefs .)
    (               reduce using rule 6 (declaration -> fundefs .)
    INTEGER         reduce using rule 6 (declaration -> fundefs .)
    FLOAT           reduce using rule 6 (declaration -> fundefs .)
    STRING          reduce using rule 6 (declaration -> fundefs .)
    $end            reduce using rule 6 (declaration -> fundefs .)
    }               reduce using rule 6 (declaration -> fundefs .)
    ELSE            reduce using rule 6 (declaration -> fundefs .)
    TYPE            shift and go to state 10

  ! TYPE            [ reduce using rule 6 (declaration -> fundefs .) ]

    fundef                         shift and go to state 11

state 4

    (2) ext_declarations -> declarations .
    (3) declarations -> declarations . declaration
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! reduce/reduce conflict for ID resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for IF resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for WHILE resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for FOR resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for RETURN resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for BREAK resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for { resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for ( resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for INTEGER resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for FLOAT resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for STRING resolved using rule 2 (ext_declarations -> declarations .)
  ! reduce/reduce conflict for $end resolved using rule 2 (ext_declarations -> declarations .)
    ID              reduce using rule 2 (ext_declarations -> declarations .)
    IF              reduce using rule 2 (ext_declarations -> declarations .)
    WHILE           reduce using rule 2 (ext_declarations -> declarations .)
    FOR             reduce using rule 2 (ext_declarations -> declarations .)
    RETURN          reduce using rule 2 (ext_declarations -> declarations .)
    BREAK           reduce using rule 2 (ext_declarations -> declarations .)
    CONTINUE        reduce using rule 2 (ext_declarations -> declarations .)
    {               reduce using rule 2 (ext_declarations -> declarations .)
    (               reduce using rule 2 (ext_declarations -> declarations .)
    INTEGER         reduce using rule 2 (ext_declarations -> declarations .)
    FLOAT           reduce using rule 2 (ext_declarations -> declarations .)
    STRING          reduce using rule 2 (ext_declarations -> declarations .)
    $end            reduce using rule 2 (ext_declarations -> declarations .)
    TYPE            shift and go to state 6
    error           shift and go to state 7

  ! TYPE            [ reduce using rule 2 (ext_declarations -> declarations .) ]
  ! error           [ reduce using rule 2 (ext_declarations -> declarations .) ]
  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]
  ! $end            [ reduce using rule 77 (fundefs -> .) ]

    declaration                    shift and go to state 12
    fundefs                        shift and go to state 3
    fundef                         shift and go to state 8

state 5

    (4) declarations -> declaration .

    TYPE            reduce using rule 4 (declarations -> declaration .)
    error           reduce using rule 4 (declarations -> declaration .)
    ID              reduce using rule 4 (declarations -> declaration .)
    IF              reduce using rule 4 (declarations -> declaration .)
    WHILE           reduce using rule 4 (declarations -> declaration .)
    FOR             reduce using rule 4 (declarations -> declaration .)
    RETURN          reduce using rule 4 (declarations -> declaration .)
    BREAK           reduce using rule 4 (declarations -> declaration .)
    CONTINUE        reduce using rule 4 (declarations -> declaration .)
    {               reduce using rule 4 (declarations -> declaration .)
    (               reduce using rule 4 (declarations -> declaration .)
    INTEGER         reduce using rule 4 (declarations -> declaration .)
    FLOAT           reduce using rule 4 (declarations -> declaration .)
    STRING          reduce using rule 4 (declarations -> declaration .)
    $end            reduce using rule 4 (declarations -> declaration .)
    }               reduce using rule 4 (declarations -> declaration .)


state 6

    (7) declaration -> TYPE . inits ;
    (78) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr
    (9) inits -> . inits , init
    (10) inits -> . init
    (11) init -> . ID = expression

    ID              shift and go to state 14

    inits                          shift and go to state 13
    init                           shift and go to state 15

state 7

    (8) declaration -> error . ;

    ;               shift and go to state 16


state 8

    (76) fundefs -> fundef .

    TYPE            reduce using rule 76 (fundefs -> fundef .)
    error           reduce using rule 76 (fundefs -> fundef .)
    ID              reduce using rule 76 (fundefs -> fundef .)
    IF              reduce using rule 76 (fundefs -> fundef .)
    WHILE           reduce using rule 76 (fundefs -> fundef .)
    FOR             reduce using rule 76 (fundefs -> fundef .)
    RETURN          reduce using rule 76 (fundefs -> fundef .)
    BREAK           reduce using rule 76 (fundefs -> fundef .)
    CONTINUE        reduce using rule 76 (fundefs -> fundef .)
    {               reduce using rule 76 (fundefs -> fundef .)
    (               reduce using rule 76 (fundefs -> fundef .)
    INTEGER         reduce using rule 76 (fundefs -> fundef .)
    FLOAT           reduce using rule 76 (fundefs -> fundef .)
    STRING          reduce using rule 76 (fundefs -> fundef .)
    $end            reduce using rule 76 (fundefs -> fundef .)
    }               reduce using rule 76 (fundefs -> fundef .)
    ELSE            reduce using rule 76 (fundefs -> fundef .)


state 9

    (1) program -> ext_declarations fundefs . instructions
    (75) fundefs -> fundefs . fundef
    (12) instructions -> . instructions instruction
    (13) instructions -> . instruction
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    TYPE            shift and go to state 20
    ID              shift and go to state 21
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    fundefs                        shift and go to state 3
    instructions                   shift and go to state 17
    fundef                         shift and go to state 18
    instruction                    shift and go to state 19
    compound_instr                 shift and go to state 23
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    const                          shift and go to state 42

state 10

    (78) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr

    ID              shift and go to state 46


state 11

    (75) fundefs -> fundefs fundef .

    TYPE            reduce using rule 75 (fundefs -> fundefs fundef .)
    error           reduce using rule 75 (fundefs -> fundefs fundef .)
    ID              reduce using rule 75 (fundefs -> fundefs fundef .)
    IF              reduce using rule 75 (fundefs -> fundefs fundef .)
    WHILE           reduce using rule 75 (fundefs -> fundefs fundef .)
    FOR             reduce using rule 75 (fundefs -> fundefs fundef .)
    RETURN          reduce using rule 75 (fundefs -> fundefs fundef .)
    BREAK           reduce using rule 75 (fundefs -> fundefs fundef .)
    CONTINUE        reduce using rule 75 (fundefs -> fundefs fundef .)
    {               reduce using rule 75 (fundefs -> fundefs fundef .)
    (               reduce using rule 75 (fundefs -> fundefs fundef .)
    INTEGER         reduce using rule 75 (fundefs -> fundefs fundef .)
    FLOAT           reduce using rule 75 (fundefs -> fundefs fundef .)
    STRING          reduce using rule 75 (fundefs -> fundefs fundef .)
    $end            reduce using rule 75 (fundefs -> fundefs fundef .)
    }               reduce using rule 75 (fundefs -> fundefs fundef .)
    ELSE            reduce using rule 75 (fundefs -> fundefs fundef .)


state 12

    (3) declarations -> declarations declaration .

    TYPE            reduce using rule 3 (declarations -> declarations declaration .)
    error           reduce using rule 3 (declarations -> declarations declaration .)
    ID              reduce using rule 3 (declarations -> declarations declaration .)
    IF              reduce using rule 3 (declarations -> declarations declaration .)
    WHILE           reduce using rule 3 (declarations -> declarations declaration .)
    FOR             reduce using rule 3 (declarations -> declarations declaration .)
    RETURN          reduce using rule 3 (declarations -> declarations declaration .)
    BREAK           reduce using rule 3 (declarations -> declarations declaration .)
    CONTINUE        reduce using rule 3 (declarations -> declarations declaration .)
    {               reduce using rule 3 (declarations -> declarations declaration .)
    (               reduce using rule 3 (declarations -> declarations declaration .)
    INTEGER         reduce using rule 3 (declarations -> declarations declaration .)
    FLOAT           reduce using rule 3 (declarations -> declarations declaration .)
    STRING          reduce using rule 3 (declarations -> declarations declaration .)
    $end            reduce using rule 3 (declarations -> declarations declaration .)


state 13

    (7) declaration -> TYPE inits . ;
    (9) inits -> inits . , init

    ;               shift and go to state 47
    ,               shift and go to state 48


state 14

    (78) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr
    (11) init -> ID . = expression

    (               shift and go to state 49
    =               shift and go to state 50


state 15

    (10) inits -> init .

    ;               reduce using rule 10 (inits -> init .)
    ,               reduce using rule 10 (inits -> init .)


state 16

    (8) declaration -> error ; .

    TYPE            reduce using rule 8 (declaration -> error ; .)
    error           reduce using rule 8 (declaration -> error ; .)
    ID              reduce using rule 8 (declaration -> error ; .)
    IF              reduce using rule 8 (declaration -> error ; .)
    WHILE           reduce using rule 8 (declaration -> error ; .)
    FOR             reduce using rule 8 (declaration -> error ; .)
    RETURN          reduce using rule 8 (declaration -> error ; .)
    BREAK           reduce using rule 8 (declaration -> error ; .)
    CONTINUE        reduce using rule 8 (declaration -> error ; .)
    {               reduce using rule 8 (declaration -> error ; .)
    (               reduce using rule 8 (declaration -> error ; .)
    INTEGER         reduce using rule 8 (declaration -> error ; .)
    FLOAT           reduce using rule 8 (declaration -> error ; .)
    STRING          reduce using rule 8 (declaration -> error ; .)
    $end            reduce using rule 8 (declaration -> error ; .)
    }               reduce using rule 8 (declaration -> error ; .)
    ELSE            reduce using rule 8 (declaration -> error ; .)


state 17

    (1) program -> ext_declarations fundefs instructions .
    (12) instructions -> instructions . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (program -> ext_declarations fundefs instructions .)
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    $end            reduce using rule 1 (program -> ext_declarations fundefs instructions .)
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]
  ! $end            [ reduce using rule 77 (fundefs -> .) ]

    fundefs                        shift and go to state 3
    instruction                    shift and go to state 51
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 18

    (75) fundefs -> fundefs fundef .
    (76) fundefs -> fundef .

  ! reduce/reduce conflict for TYPE resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for ID resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for error resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for IF resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for WHILE resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for FOR resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for RETURN resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for BREAK resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for { resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for ( resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for INTEGER resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for FLOAT resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for STRING resolved using rule 75 (fundefs -> fundefs fundef .)
  ! reduce/reduce conflict for $end resolved using rule 75 (fundefs -> fundefs fundef .)
    TYPE            reduce using rule 75 (fundefs -> fundefs fundef .)
    ID              reduce using rule 75 (fundefs -> fundefs fundef .)
    error           reduce using rule 75 (fundefs -> fundefs fundef .)
    IF              reduce using rule 75 (fundefs -> fundefs fundef .)
    WHILE           reduce using rule 75 (fundefs -> fundefs fundef .)
    FOR             reduce using rule 75 (fundefs -> fundefs fundef .)
    RETURN          reduce using rule 75 (fundefs -> fundefs fundef .)
    BREAK           reduce using rule 75 (fundefs -> fundefs fundef .)
    CONTINUE        reduce using rule 75 (fundefs -> fundefs fundef .)
    {               reduce using rule 75 (fundefs -> fundefs fundef .)
    (               reduce using rule 75 (fundefs -> fundefs fundef .)
    INTEGER         reduce using rule 75 (fundefs -> fundefs fundef .)
    FLOAT           reduce using rule 75 (fundefs -> fundefs fundef .)
    STRING          reduce using rule 75 (fundefs -> fundefs fundef .)
    $end            reduce using rule 75 (fundefs -> fundefs fundef .)

  ! TYPE            [ reduce using rule 76 (fundefs -> fundef .) ]
  ! ID              [ reduce using rule 76 (fundefs -> fundef .) ]
  ! error           [ reduce using rule 76 (fundefs -> fundef .) ]
  ! IF              [ reduce using rule 76 (fundefs -> fundef .) ]
  ! WHILE           [ reduce using rule 76 (fundefs -> fundef .) ]
  ! FOR             [ reduce using rule 76 (fundefs -> fundef .) ]
  ! RETURN          [ reduce using rule 76 (fundefs -> fundef .) ]
  ! BREAK           [ reduce using rule 76 (fundefs -> fundef .) ]
  ! CONTINUE        [ reduce using rule 76 (fundefs -> fundef .) ]
  ! {               [ reduce using rule 76 (fundefs -> fundef .) ]
  ! (               [ reduce using rule 76 (fundefs -> fundef .) ]
  ! INTEGER         [ reduce using rule 76 (fundefs -> fundef .) ]
  ! FLOAT           [ reduce using rule 76 (fundefs -> fundef .) ]
  ! STRING          [ reduce using rule 76 (fundefs -> fundef .) ]
  ! $end            [ reduce using rule 76 (fundefs -> fundef .) ]


state 19

    (13) instructions -> instruction .

    ID              reduce using rule 13 (instructions -> instruction .)
    TYPE            reduce using rule 13 (instructions -> instruction .)
    error           reduce using rule 13 (instructions -> instruction .)
    IF              reduce using rule 13 (instructions -> instruction .)
    WHILE           reduce using rule 13 (instructions -> instruction .)
    FOR             reduce using rule 13 (instructions -> instruction .)
    RETURN          reduce using rule 13 (instructions -> instruction .)
    BREAK           reduce using rule 13 (instructions -> instruction .)
    CONTINUE        reduce using rule 13 (instructions -> instruction .)
    {               reduce using rule 13 (instructions -> instruction .)
    (               reduce using rule 13 (instructions -> instruction .)
    INTEGER         reduce using rule 13 (instructions -> instruction .)
    FLOAT           reduce using rule 13 (instructions -> instruction .)
    STRING          reduce using rule 13 (instructions -> instruction .)
    $end            reduce using rule 13 (instructions -> instruction .)
    }               reduce using rule 13 (instructions -> instruction .)


state 20

    (78) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr
    (7) declaration -> TYPE . inits ;
    (9) inits -> . inits , init
    (10) inits -> . init
    (11) init -> . ID = expression

    ID              shift and go to state 14

    inits                          shift and go to state 13
    init                           shift and go to state 15

state 21

    (27) labeled_instr -> ID . : instruction
    (28) assignment -> ID . = expression
    (29) assignment -> ID . = error ;
    (26) statement -> ID . ( expr_list_or_empty ) ;
    (48) expression -> ID .
    (51) expression -> ID . ( expr_list_or_empty )
    (52) expression -> ID . ( error )

    :               shift and go to state 52
    =               shift and go to state 53
    (               shift and go to state 54
    ;               reduce using rule 48 (expression -> ID .)
    +               reduce using rule 48 (expression -> ID .)
    -               reduce using rule 48 (expression -> ID .)
    *               reduce using rule 48 (expression -> ID .)
    /               reduce using rule 48 (expression -> ID .)
    %               reduce using rule 48 (expression -> ID .)
    |               reduce using rule 48 (expression -> ID .)
    &               reduce using rule 48 (expression -> ID .)
    ^               reduce using rule 48 (expression -> ID .)
    AND             reduce using rule 48 (expression -> ID .)
    OR              reduce using rule 48 (expression -> ID .)
    SHL             reduce using rule 48 (expression -> ID .)
    SHR             reduce using rule 48 (expression -> ID .)
    EQ              reduce using rule 48 (expression -> ID .)
    NEQ             reduce using rule 48 (expression -> ID .)
    >               reduce using rule 48 (expression -> ID .)
    <               reduce using rule 48 (expression -> ID .)
    LE              reduce using rule 48 (expression -> ID .)
    GE              reduce using rule 48 (expression -> ID .)


state 22

    (49) expression -> ( . expression )
    (50) expression -> ( . error )
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    error           shift and go to state 56
    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 55
    const                          shift and go to state 42

state 23

    (23) instruction -> compound_instr .

    ID              reduce using rule 23 (instruction -> compound_instr .)
    TYPE            reduce using rule 23 (instruction -> compound_instr .)
    error           reduce using rule 23 (instruction -> compound_instr .)
    IF              reduce using rule 23 (instruction -> compound_instr .)
    WHILE           reduce using rule 23 (instruction -> compound_instr .)
    FOR             reduce using rule 23 (instruction -> compound_instr .)
    RETURN          reduce using rule 23 (instruction -> compound_instr .)
    BREAK           reduce using rule 23 (instruction -> compound_instr .)
    CONTINUE        reduce using rule 23 (instruction -> compound_instr .)
    {               reduce using rule 23 (instruction -> compound_instr .)
    (               reduce using rule 23 (instruction -> compound_instr .)
    INTEGER         reduce using rule 23 (instruction -> compound_instr .)
    FLOAT           reduce using rule 23 (instruction -> compound_instr .)
    STRING          reduce using rule 23 (instruction -> compound_instr .)
    $end            reduce using rule 23 (instruction -> compound_instr .)
    }               reduce using rule 23 (instruction -> compound_instr .)
    ELSE            reduce using rule 23 (instruction -> compound_instr .)


state 24

    (14) instruction -> labeled_instr .

    ID              reduce using rule 14 (instruction -> labeled_instr .)
    TYPE            reduce using rule 14 (instruction -> labeled_instr .)
    error           reduce using rule 14 (instruction -> labeled_instr .)
    IF              reduce using rule 14 (instruction -> labeled_instr .)
    WHILE           reduce using rule 14 (instruction -> labeled_instr .)
    FOR             reduce using rule 14 (instruction -> labeled_instr .)
    RETURN          reduce using rule 14 (instruction -> labeled_instr .)
    BREAK           reduce using rule 14 (instruction -> labeled_instr .)
    CONTINUE        reduce using rule 14 (instruction -> labeled_instr .)
    {               reduce using rule 14 (instruction -> labeled_instr .)
    (               reduce using rule 14 (instruction -> labeled_instr .)
    INTEGER         reduce using rule 14 (instruction -> labeled_instr .)
    FLOAT           reduce using rule 14 (instruction -> labeled_instr .)
    STRING          reduce using rule 14 (instruction -> labeled_instr .)
    $end            reduce using rule 14 (instruction -> labeled_instr .)
    }               reduce using rule 14 (instruction -> labeled_instr .)
    ELSE            reduce using rule 14 (instruction -> labeled_instr .)


state 25

    (15) instruction -> assignment . ;

    ;               shift and go to state 58


state 26

    (16) instruction -> declaration .

    ID              reduce using rule 16 (instruction -> declaration .)
    TYPE            reduce using rule 16 (instruction -> declaration .)
    error           reduce using rule 16 (instruction -> declaration .)
    IF              reduce using rule 16 (instruction -> declaration .)
    WHILE           reduce using rule 16 (instruction -> declaration .)
    FOR             reduce using rule 16 (instruction -> declaration .)
    RETURN          reduce using rule 16 (instruction -> declaration .)
    BREAK           reduce using rule 16 (instruction -> declaration .)
    CONTINUE        reduce using rule 16 (instruction -> declaration .)
    {               reduce using rule 16 (instruction -> declaration .)
    (               reduce using rule 16 (instruction -> declaration .)
    INTEGER         reduce using rule 16 (instruction -> declaration .)
    FLOAT           reduce using rule 16 (instruction -> declaration .)
    STRING          reduce using rule 16 (instruction -> declaration .)
    $end            reduce using rule 16 (instruction -> declaration .)
    }               reduce using rule 16 (instruction -> declaration .)
    ELSE            reduce using rule 16 (instruction -> declaration .)


state 27

    (17) instruction -> choice_instr .

    ID              reduce using rule 17 (instruction -> choice_instr .)
    TYPE            reduce using rule 17 (instruction -> choice_instr .)
    error           reduce using rule 17 (instruction -> choice_instr .)
    IF              reduce using rule 17 (instruction -> choice_instr .)
    WHILE           reduce using rule 17 (instruction -> choice_instr .)
    FOR             reduce using rule 17 (instruction -> choice_instr .)
    RETURN          reduce using rule 17 (instruction -> choice_instr .)
    BREAK           reduce using rule 17 (instruction -> choice_instr .)
    CONTINUE        reduce using rule 17 (instruction -> choice_instr .)
    {               reduce using rule 17 (instruction -> choice_instr .)
    (               reduce using rule 17 (instruction -> choice_instr .)
    INTEGER         reduce using rule 17 (instruction -> choice_instr .)
    FLOAT           reduce using rule 17 (instruction -> choice_instr .)
    STRING          reduce using rule 17 (instruction -> choice_instr .)
    $end            reduce using rule 17 (instruction -> choice_instr .)
    }               reduce using rule 17 (instruction -> choice_instr .)
    ELSE            reduce using rule 17 (instruction -> choice_instr .)


state 28

    (18) instruction -> while_instr .

    ID              reduce using rule 18 (instruction -> while_instr .)
    TYPE            reduce using rule 18 (instruction -> while_instr .)
    error           reduce using rule 18 (instruction -> while_instr .)
    IF              reduce using rule 18 (instruction -> while_instr .)
    WHILE           reduce using rule 18 (instruction -> while_instr .)
    FOR             reduce using rule 18 (instruction -> while_instr .)
    RETURN          reduce using rule 18 (instruction -> while_instr .)
    BREAK           reduce using rule 18 (instruction -> while_instr .)
    CONTINUE        reduce using rule 18 (instruction -> while_instr .)
    {               reduce using rule 18 (instruction -> while_instr .)
    (               reduce using rule 18 (instruction -> while_instr .)
    INTEGER         reduce using rule 18 (instruction -> while_instr .)
    FLOAT           reduce using rule 18 (instruction -> while_instr .)
    STRING          reduce using rule 18 (instruction -> while_instr .)
    $end            reduce using rule 18 (instruction -> while_instr .)
    }               reduce using rule 18 (instruction -> while_instr .)
    ELSE            reduce using rule 18 (instruction -> while_instr .)


state 29

    (19) instruction -> for_instr .

    ID              reduce using rule 19 (instruction -> for_instr .)
    TYPE            reduce using rule 19 (instruction -> for_instr .)
    error           reduce using rule 19 (instruction -> for_instr .)
    IF              reduce using rule 19 (instruction -> for_instr .)
    WHILE           reduce using rule 19 (instruction -> for_instr .)
    FOR             reduce using rule 19 (instruction -> for_instr .)
    RETURN          reduce using rule 19 (instruction -> for_instr .)
    BREAK           reduce using rule 19 (instruction -> for_instr .)
    CONTINUE        reduce using rule 19 (instruction -> for_instr .)
    {               reduce using rule 19 (instruction -> for_instr .)
    (               reduce using rule 19 (instruction -> for_instr .)
    INTEGER         reduce using rule 19 (instruction -> for_instr .)
    FLOAT           reduce using rule 19 (instruction -> for_instr .)
    STRING          reduce using rule 19 (instruction -> for_instr .)
    $end            reduce using rule 19 (instruction -> for_instr .)
    }               reduce using rule 19 (instruction -> for_instr .)
    ELSE            reduce using rule 19 (instruction -> for_instr .)


state 30

    (20) instruction -> return_instr .

    ID              reduce using rule 20 (instruction -> return_instr .)
    TYPE            reduce using rule 20 (instruction -> return_instr .)
    error           reduce using rule 20 (instruction -> return_instr .)
    IF              reduce using rule 20 (instruction -> return_instr .)
    WHILE           reduce using rule 20 (instruction -> return_instr .)
    FOR             reduce using rule 20 (instruction -> return_instr .)
    RETURN          reduce using rule 20 (instruction -> return_instr .)
    BREAK           reduce using rule 20 (instruction -> return_instr .)
    CONTINUE        reduce using rule 20 (instruction -> return_instr .)
    {               reduce using rule 20 (instruction -> return_instr .)
    (               reduce using rule 20 (instruction -> return_instr .)
    INTEGER         reduce using rule 20 (instruction -> return_instr .)
    FLOAT           reduce using rule 20 (instruction -> return_instr .)
    STRING          reduce using rule 20 (instruction -> return_instr .)
    $end            reduce using rule 20 (instruction -> return_instr .)
    }               reduce using rule 20 (instruction -> return_instr .)
    ELSE            reduce using rule 20 (instruction -> return_instr .)


state 31

    (21) instruction -> break_instr .

    ID              reduce using rule 21 (instruction -> break_instr .)
    TYPE            reduce using rule 21 (instruction -> break_instr .)
    error           reduce using rule 21 (instruction -> break_instr .)
    IF              reduce using rule 21 (instruction -> break_instr .)
    WHILE           reduce using rule 21 (instruction -> break_instr .)
    FOR             reduce using rule 21 (instruction -> break_instr .)
    RETURN          reduce using rule 21 (instruction -> break_instr .)
    BREAK           reduce using rule 21 (instruction -> break_instr .)
    CONTINUE        reduce using rule 21 (instruction -> break_instr .)
    {               reduce using rule 21 (instruction -> break_instr .)
    (               reduce using rule 21 (instruction -> break_instr .)
    INTEGER         reduce using rule 21 (instruction -> break_instr .)
    FLOAT           reduce using rule 21 (instruction -> break_instr .)
    STRING          reduce using rule 21 (instruction -> break_instr .)
    $end            reduce using rule 21 (instruction -> break_instr .)
    }               reduce using rule 21 (instruction -> break_instr .)
    ELSE            reduce using rule 21 (instruction -> break_instr .)


state 32

    (22) instruction -> continue_instr .

    ID              reduce using rule 22 (instruction -> continue_instr .)
    TYPE            reduce using rule 22 (instruction -> continue_instr .)
    error           reduce using rule 22 (instruction -> continue_instr .)
    IF              reduce using rule 22 (instruction -> continue_instr .)
    WHILE           reduce using rule 22 (instruction -> continue_instr .)
    FOR             reduce using rule 22 (instruction -> continue_instr .)
    RETURN          reduce using rule 22 (instruction -> continue_instr .)
    BREAK           reduce using rule 22 (instruction -> continue_instr .)
    CONTINUE        reduce using rule 22 (instruction -> continue_instr .)
    {               reduce using rule 22 (instruction -> continue_instr .)
    (               reduce using rule 22 (instruction -> continue_instr .)
    INTEGER         reduce using rule 22 (instruction -> continue_instr .)
    FLOAT           reduce using rule 22 (instruction -> continue_instr .)
    STRING          reduce using rule 22 (instruction -> continue_instr .)
    $end            reduce using rule 22 (instruction -> continue_instr .)
    }               reduce using rule 22 (instruction -> continue_instr .)
    ELSE            reduce using rule 22 (instruction -> continue_instr .)


state 33

    (24) instruction -> statement .

    ID              reduce using rule 24 (instruction -> statement .)
    TYPE            reduce using rule 24 (instruction -> statement .)
    error           reduce using rule 24 (instruction -> statement .)
    IF              reduce using rule 24 (instruction -> statement .)
    WHILE           reduce using rule 24 (instruction -> statement .)
    FOR             reduce using rule 24 (instruction -> statement .)
    RETURN          reduce using rule 24 (instruction -> statement .)
    BREAK           reduce using rule 24 (instruction -> statement .)
    CONTINUE        reduce using rule 24 (instruction -> statement .)
    {               reduce using rule 24 (instruction -> statement .)
    (               reduce using rule 24 (instruction -> statement .)
    INTEGER         reduce using rule 24 (instruction -> statement .)
    FLOAT           reduce using rule 24 (instruction -> statement .)
    STRING          reduce using rule 24 (instruction -> statement .)
    $end            reduce using rule 24 (instruction -> statement .)
    }               reduce using rule 24 (instruction -> statement .)
    ELSE            reduce using rule 24 (instruction -> statement .)


state 34

    (25) instruction -> expression . ;
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 35

    (30) choice_instr -> IF . ( condition ) instruction
    (31) choice_instr -> IF . ( condition ) instruction ELSE instruction
    (32) choice_instr -> IF . ( error ) instruction
    (33) choice_instr -> IF . ( error ) instruction ELSE instruction

    (               shift and go to state 78


state 36

    (34) while_instr -> WHILE . ( condition ) instruction
    (37) while_instr -> WHILE . ( error ) instruction

    (               shift and go to state 79


state 37

    (35) for_instr -> FOR . ( instruction expression ; assignment ) instruction
    (36) for_instr -> FOR . ( error ) instruction

    (               shift and go to state 80


state 38

    (38) return_instr -> RETURN . expression ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 81
    const                          shift and go to state 42

state 39

    (40) break_instr -> BREAK . ;

    ;               shift and go to state 82


state 40

    (39) continue_instr -> CONTINUE . ;

    ;               shift and go to state 83


state 41

    (41) compound_instr -> { . declarations instructions }
    (42) compound_instr -> { . }
    (3) declarations -> . declarations declaration
    (4) declarations -> . declaration
    (5) declarations -> .
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! reduce/reduce conflict for ID resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for IF resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for FOR resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for BREAK resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for { resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for ( resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for INTEGER resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for FLOAT resolved using rule 5 (declarations -> .)
  ! reduce/reduce conflict for STRING resolved using rule 5 (declarations -> .)
  ! shift/reduce conflict for } resolved as shift
    }               shift and go to state 85
    ID              reduce using rule 5 (declarations -> .)
    IF              reduce using rule 5 (declarations -> .)
    WHILE           reduce using rule 5 (declarations -> .)
    FOR             reduce using rule 5 (declarations -> .)
    RETURN          reduce using rule 5 (declarations -> .)
    BREAK           reduce using rule 5 (declarations -> .)
    CONTINUE        reduce using rule 5 (declarations -> .)
    {               reduce using rule 5 (declarations -> .)
    (               reduce using rule 5 (declarations -> .)
    INTEGER         reduce using rule 5 (declarations -> .)
    FLOAT           reduce using rule 5 (declarations -> .)
    STRING          reduce using rule 5 (declarations -> .)
    TYPE            shift and go to state 6
    error           shift and go to state 7

  ! TYPE            [ reduce using rule 5 (declarations -> .) ]
  ! error           [ reduce using rule 5 (declarations -> .) ]
  ! }               [ reduce using rule 5 (declarations -> .) ]
  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]
  ! }               [ reduce using rule 77 (fundefs -> .) ]

    declarations                   shift and go to state 84
    declaration                    shift and go to state 5
    fundefs                        shift and go to state 3
    fundef                         shift and go to state 8

state 42

    (47) expression -> const .

    ;               reduce using rule 47 (expression -> const .)
    +               reduce using rule 47 (expression -> const .)
    -               reduce using rule 47 (expression -> const .)
    *               reduce using rule 47 (expression -> const .)
    /               reduce using rule 47 (expression -> const .)
    %               reduce using rule 47 (expression -> const .)
    |               reduce using rule 47 (expression -> const .)
    &               reduce using rule 47 (expression -> const .)
    ^               reduce using rule 47 (expression -> const .)
    AND             reduce using rule 47 (expression -> const .)
    OR              reduce using rule 47 (expression -> const .)
    SHL             reduce using rule 47 (expression -> const .)
    SHR             reduce using rule 47 (expression -> const .)
    EQ              reduce using rule 47 (expression -> const .)
    NEQ             reduce using rule 47 (expression -> const .)
    >               reduce using rule 47 (expression -> const .)
    <               reduce using rule 47 (expression -> const .)
    LE              reduce using rule 47 (expression -> const .)
    GE              reduce using rule 47 (expression -> const .)
    )               reduce using rule 47 (expression -> const .)
    ,               reduce using rule 47 (expression -> const .)


state 43

    (44) const -> INTEGER .

    ;               reduce using rule 44 (const -> INTEGER .)
    +               reduce using rule 44 (const -> INTEGER .)
    -               reduce using rule 44 (const -> INTEGER .)
    *               reduce using rule 44 (const -> INTEGER .)
    /               reduce using rule 44 (const -> INTEGER .)
    %               reduce using rule 44 (const -> INTEGER .)
    |               reduce using rule 44 (const -> INTEGER .)
    &               reduce using rule 44 (const -> INTEGER .)
    ^               reduce using rule 44 (const -> INTEGER .)
    AND             reduce using rule 44 (const -> INTEGER .)
    OR              reduce using rule 44 (const -> INTEGER .)
    SHL             reduce using rule 44 (const -> INTEGER .)
    SHR             reduce using rule 44 (const -> INTEGER .)
    EQ              reduce using rule 44 (const -> INTEGER .)
    NEQ             reduce using rule 44 (const -> INTEGER .)
    >               reduce using rule 44 (const -> INTEGER .)
    <               reduce using rule 44 (const -> INTEGER .)
    LE              reduce using rule 44 (const -> INTEGER .)
    GE              reduce using rule 44 (const -> INTEGER .)
    )               reduce using rule 44 (const -> INTEGER .)
    ,               reduce using rule 44 (const -> INTEGER .)


state 44

    (45) const -> FLOAT .

    ;               reduce using rule 45 (const -> FLOAT .)
    +               reduce using rule 45 (const -> FLOAT .)
    -               reduce using rule 45 (const -> FLOAT .)
    *               reduce using rule 45 (const -> FLOAT .)
    /               reduce using rule 45 (const -> FLOAT .)
    %               reduce using rule 45 (const -> FLOAT .)
    |               reduce using rule 45 (const -> FLOAT .)
    &               reduce using rule 45 (const -> FLOAT .)
    ^               reduce using rule 45 (const -> FLOAT .)
    AND             reduce using rule 45 (const -> FLOAT .)
    OR              reduce using rule 45 (const -> FLOAT .)
    SHL             reduce using rule 45 (const -> FLOAT .)
    SHR             reduce using rule 45 (const -> FLOAT .)
    EQ              reduce using rule 45 (const -> FLOAT .)
    NEQ             reduce using rule 45 (const -> FLOAT .)
    >               reduce using rule 45 (const -> FLOAT .)
    <               reduce using rule 45 (const -> FLOAT .)
    LE              reduce using rule 45 (const -> FLOAT .)
    GE              reduce using rule 45 (const -> FLOAT .)
    )               reduce using rule 45 (const -> FLOAT .)
    ,               reduce using rule 45 (const -> FLOAT .)


state 45

    (46) const -> STRING .

    ;               reduce using rule 46 (const -> STRING .)
    +               reduce using rule 46 (const -> STRING .)
    -               reduce using rule 46 (const -> STRING .)
    *               reduce using rule 46 (const -> STRING .)
    /               reduce using rule 46 (const -> STRING .)
    %               reduce using rule 46 (const -> STRING .)
    |               reduce using rule 46 (const -> STRING .)
    &               reduce using rule 46 (const -> STRING .)
    ^               reduce using rule 46 (const -> STRING .)
    AND             reduce using rule 46 (const -> STRING .)
    OR              reduce using rule 46 (const -> STRING .)
    SHL             reduce using rule 46 (const -> STRING .)
    SHR             reduce using rule 46 (const -> STRING .)
    EQ              reduce using rule 46 (const -> STRING .)
    NEQ             reduce using rule 46 (const -> STRING .)
    >               reduce using rule 46 (const -> STRING .)
    <               reduce using rule 46 (const -> STRING .)
    LE              reduce using rule 46 (const -> STRING .)
    GE              reduce using rule 46 (const -> STRING .)
    )               reduce using rule 46 (const -> STRING .)
    ,               reduce using rule 46 (const -> STRING .)


state 46

    (78) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr

    (               shift and go to state 49


state 47

    (7) declaration -> TYPE inits ; .

    TYPE            reduce using rule 7 (declaration -> TYPE inits ; .)
    error           reduce using rule 7 (declaration -> TYPE inits ; .)
    ID              reduce using rule 7 (declaration -> TYPE inits ; .)
    IF              reduce using rule 7 (declaration -> TYPE inits ; .)
    WHILE           reduce using rule 7 (declaration -> TYPE inits ; .)
    FOR             reduce using rule 7 (declaration -> TYPE inits ; .)
    RETURN          reduce using rule 7 (declaration -> TYPE inits ; .)
    BREAK           reduce using rule 7 (declaration -> TYPE inits ; .)
    CONTINUE        reduce using rule 7 (declaration -> TYPE inits ; .)
    {               reduce using rule 7 (declaration -> TYPE inits ; .)
    (               reduce using rule 7 (declaration -> TYPE inits ; .)
    INTEGER         reduce using rule 7 (declaration -> TYPE inits ; .)
    FLOAT           reduce using rule 7 (declaration -> TYPE inits ; .)
    STRING          reduce using rule 7 (declaration -> TYPE inits ; .)
    $end            reduce using rule 7 (declaration -> TYPE inits ; .)
    }               reduce using rule 7 (declaration -> TYPE inits ; .)
    ELSE            reduce using rule 7 (declaration -> TYPE inits ; .)


state 48

    (9) inits -> inits , . init
    (11) init -> . ID = expression

    ID              shift and go to state 87

    init                           shift and go to state 86

state 49

    (78) fundef -> TYPE ID ( . args_list_or_empty ) compound_instr
    (79) args_list_or_empty -> . args_list
    (80) args_list_or_empty -> .
    (81) args_list -> . args_list , arg
    (82) args_list -> . arg
    (83) arg -> . TYPE ID

    )               reduce using rule 80 (args_list_or_empty -> .)
    TYPE            shift and go to state 88

    args_list_or_empty             shift and go to state 89
    args_list                      shift and go to state 90
    arg                            shift and go to state 91

state 50

    (11) init -> ID = . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 92
    const                          shift and go to state 42

state 51

    (12) instructions -> instructions instruction .

    ID              reduce using rule 12 (instructions -> instructions instruction .)
    TYPE            reduce using rule 12 (instructions -> instructions instruction .)
    error           reduce using rule 12 (instructions -> instructions instruction .)
    IF              reduce using rule 12 (instructions -> instructions instruction .)
    WHILE           reduce using rule 12 (instructions -> instructions instruction .)
    FOR             reduce using rule 12 (instructions -> instructions instruction .)
    RETURN          reduce using rule 12 (instructions -> instructions instruction .)
    BREAK           reduce using rule 12 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 12 (instructions -> instructions instruction .)
    {               reduce using rule 12 (instructions -> instructions instruction .)
    (               reduce using rule 12 (instructions -> instructions instruction .)
    INTEGER         reduce using rule 12 (instructions -> instructions instruction .)
    FLOAT           reduce using rule 12 (instructions -> instructions instruction .)
    STRING          reduce using rule 12 (instructions -> instructions instruction .)
    $end            reduce using rule 12 (instructions -> instructions instruction .)
    }               reduce using rule 12 (instructions -> instructions instruction .)


state 52

    (27) labeled_instr -> ID : . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 93
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 53

    (28) assignment -> ID = . expression
    (29) assignment -> ID = . error ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    error           shift and go to state 95
    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 94
    const                          shift and go to state 42

state 54

    (26) statement -> ID ( . expr_list_or_empty ) ;
    (51) expression -> ID ( . expr_list_or_empty )
    (52) expression -> ID ( . error )
    (71) expr_list_or_empty -> . expr_list
    (72) expr_list_or_empty -> .
    (73) expr_list -> . expr_list , expression
    (74) expr_list -> . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    error           shift and go to state 97
    )               reduce using rule 72 (expr_list_or_empty -> .)
    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expr_list_or_empty             shift and go to state 96
    expr_list                      shift and go to state 98
    expression                     shift and go to state 99
    const                          shift and go to state 42

state 55

    (49) expression -> ( expression . )
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    )               shift and go to state 100
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 56

    (50) expression -> ( error . )

    )               shift and go to state 101


state 57

    (48) expression -> ID .
    (51) expression -> ID . ( expr_list_or_empty )
    (52) expression -> ID . ( error )

    )               reduce using rule 48 (expression -> ID .)
    +               reduce using rule 48 (expression -> ID .)
    -               reduce using rule 48 (expression -> ID .)
    *               reduce using rule 48 (expression -> ID .)
    /               reduce using rule 48 (expression -> ID .)
    %               reduce using rule 48 (expression -> ID .)
    |               reduce using rule 48 (expression -> ID .)
    &               reduce using rule 48 (expression -> ID .)
    ^               reduce using rule 48 (expression -> ID .)
    AND             reduce using rule 48 (expression -> ID .)
    OR              reduce using rule 48 (expression -> ID .)
    SHL             reduce using rule 48 (expression -> ID .)
    SHR             reduce using rule 48 (expression -> ID .)
    EQ              reduce using rule 48 (expression -> ID .)
    NEQ             reduce using rule 48 (expression -> ID .)
    >               reduce using rule 48 (expression -> ID .)
    <               reduce using rule 48 (expression -> ID .)
    LE              reduce using rule 48 (expression -> ID .)
    GE              reduce using rule 48 (expression -> ID .)
    ;               reduce using rule 48 (expression -> ID .)
    ,               reduce using rule 48 (expression -> ID .)
    (               shift and go to state 102


state 58

    (15) instruction -> assignment ; .

    ID              reduce using rule 15 (instruction -> assignment ; .)
    TYPE            reduce using rule 15 (instruction -> assignment ; .)
    error           reduce using rule 15 (instruction -> assignment ; .)
    IF              reduce using rule 15 (instruction -> assignment ; .)
    WHILE           reduce using rule 15 (instruction -> assignment ; .)
    FOR             reduce using rule 15 (instruction -> assignment ; .)
    RETURN          reduce using rule 15 (instruction -> assignment ; .)
    BREAK           reduce using rule 15 (instruction -> assignment ; .)
    CONTINUE        reduce using rule 15 (instruction -> assignment ; .)
    {               reduce using rule 15 (instruction -> assignment ; .)
    (               reduce using rule 15 (instruction -> assignment ; .)
    INTEGER         reduce using rule 15 (instruction -> assignment ; .)
    FLOAT           reduce using rule 15 (instruction -> assignment ; .)
    STRING          reduce using rule 15 (instruction -> assignment ; .)
    $end            reduce using rule 15 (instruction -> assignment ; .)
    }               reduce using rule 15 (instruction -> assignment ; .)
    ELSE            reduce using rule 15 (instruction -> assignment ; .)


state 59

    (25) instruction -> expression ; .

    ID              reduce using rule 25 (instruction -> expression ; .)
    TYPE            reduce using rule 25 (instruction -> expression ; .)
    error           reduce using rule 25 (instruction -> expression ; .)
    IF              reduce using rule 25 (instruction -> expression ; .)
    WHILE           reduce using rule 25 (instruction -> expression ; .)
    FOR             reduce using rule 25 (instruction -> expression ; .)
    RETURN          reduce using rule 25 (instruction -> expression ; .)
    BREAK           reduce using rule 25 (instruction -> expression ; .)
    CONTINUE        reduce using rule 25 (instruction -> expression ; .)
    {               reduce using rule 25 (instruction -> expression ; .)
    (               reduce using rule 25 (instruction -> expression ; .)
    INTEGER         reduce using rule 25 (instruction -> expression ; .)
    FLOAT           reduce using rule 25 (instruction -> expression ; .)
    STRING          reduce using rule 25 (instruction -> expression ; .)
    $end            reduce using rule 25 (instruction -> expression ; .)
    }               reduce using rule 25 (instruction -> expression ; .)
    ELSE            reduce using rule 25 (instruction -> expression ; .)


state 60

    (53) expression -> expression + . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 103
    const                          shift and go to state 42

state 61

    (54) expression -> expression - . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 104
    const                          shift and go to state 42

state 62

    (55) expression -> expression * . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 105
    const                          shift and go to state 42

state 63

    (56) expression -> expression / . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 106
    const                          shift and go to state 42

state 64

    (57) expression -> expression % . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 107
    const                          shift and go to state 42

state 65

    (58) expression -> expression | . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 108
    const                          shift and go to state 42

state 66

    (59) expression -> expression & . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 109
    const                          shift and go to state 42

state 67

    (60) expression -> expression ^ . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 110
    const                          shift and go to state 42

state 68

    (61) expression -> expression AND . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 111
    const                          shift and go to state 42

state 69

    (62) expression -> expression OR . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 112
    const                          shift and go to state 42

state 70

    (63) expression -> expression SHL . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 113
    const                          shift and go to state 42

state 71

    (64) expression -> expression SHR . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 114
    const                          shift and go to state 42

state 72

    (65) expression -> expression EQ . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 115
    const                          shift and go to state 42

state 73

    (66) expression -> expression NEQ . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 116
    const                          shift and go to state 42

state 74

    (67) expression -> expression > . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 117
    const                          shift and go to state 42

state 75

    (68) expression -> expression < . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 118
    const                          shift and go to state 42

state 76

    (69) expression -> expression LE . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 119
    const                          shift and go to state 42

state 77

    (70) expression -> expression GE . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 120
    const                          shift and go to state 42

state 78

    (30) choice_instr -> IF ( . condition ) instruction
    (31) choice_instr -> IF ( . condition ) instruction ELSE instruction
    (32) choice_instr -> IF ( . error ) instruction
    (33) choice_instr -> IF ( . error ) instruction ELSE instruction
    (43) condition -> . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    error           shift and go to state 122
    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    condition                      shift and go to state 121
    expression                     shift and go to state 123
    const                          shift and go to state 42

state 79

    (34) while_instr -> WHILE ( . condition ) instruction
    (37) while_instr -> WHILE ( . error ) instruction
    (43) condition -> . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    error           shift and go to state 125
    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    condition                      shift and go to state 124
    expression                     shift and go to state 123
    const                          shift and go to state 42

state 80

    (35) for_instr -> FOR ( . instruction expression ; assignment ) instruction
    (36) for_instr -> FOR ( . error ) instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    error           shift and go to state 127
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 126
    expression                     shift and go to state 34
    assignment                     shift and go to state 25
    labeled_instr                  shift and go to state 24
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 81

    (38) return_instr -> RETURN expression . ;
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               shift and go to state 128
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 82

    (40) break_instr -> BREAK ; .

    ID              reduce using rule 40 (break_instr -> BREAK ; .)
    TYPE            reduce using rule 40 (break_instr -> BREAK ; .)
    error           reduce using rule 40 (break_instr -> BREAK ; .)
    IF              reduce using rule 40 (break_instr -> BREAK ; .)
    WHILE           reduce using rule 40 (break_instr -> BREAK ; .)
    FOR             reduce using rule 40 (break_instr -> BREAK ; .)
    RETURN          reduce using rule 40 (break_instr -> BREAK ; .)
    BREAK           reduce using rule 40 (break_instr -> BREAK ; .)
    CONTINUE        reduce using rule 40 (break_instr -> BREAK ; .)
    {               reduce using rule 40 (break_instr -> BREAK ; .)
    (               reduce using rule 40 (break_instr -> BREAK ; .)
    INTEGER         reduce using rule 40 (break_instr -> BREAK ; .)
    FLOAT           reduce using rule 40 (break_instr -> BREAK ; .)
    STRING          reduce using rule 40 (break_instr -> BREAK ; .)
    $end            reduce using rule 40 (break_instr -> BREAK ; .)
    }               reduce using rule 40 (break_instr -> BREAK ; .)
    ELSE            reduce using rule 40 (break_instr -> BREAK ; .)


state 83

    (39) continue_instr -> CONTINUE ; .

    ID              reduce using rule 39 (continue_instr -> CONTINUE ; .)
    TYPE            reduce using rule 39 (continue_instr -> CONTINUE ; .)
    error           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    IF              reduce using rule 39 (continue_instr -> CONTINUE ; .)
    WHILE           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    FOR             reduce using rule 39 (continue_instr -> CONTINUE ; .)
    RETURN          reduce using rule 39 (continue_instr -> CONTINUE ; .)
    BREAK           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    CONTINUE        reduce using rule 39 (continue_instr -> CONTINUE ; .)
    {               reduce using rule 39 (continue_instr -> CONTINUE ; .)
    (               reduce using rule 39 (continue_instr -> CONTINUE ; .)
    INTEGER         reduce using rule 39 (continue_instr -> CONTINUE ; .)
    FLOAT           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    STRING          reduce using rule 39 (continue_instr -> CONTINUE ; .)
    $end            reduce using rule 39 (continue_instr -> CONTINUE ; .)
    }               reduce using rule 39 (continue_instr -> CONTINUE ; .)
    ELSE            reduce using rule 39 (continue_instr -> CONTINUE ; .)


state 84

    (41) compound_instr -> { declarations . instructions }
    (3) declarations -> declarations . declaration
    (12) instructions -> . instructions instruction
    (13) instructions -> . instruction
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    TYPE            shift and go to state 6
    error           shift and go to state 7
    }               reduce using rule 77 (fundefs -> .)
    ID              shift and go to state 21
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instructions                   shift and go to state 129
    declaration                    shift and go to state 130
    instruction                    shift and go to state 19
    fundefs                        shift and go to state 3
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundef                         shift and go to state 8
    const                          shift and go to state 42

state 85

    (42) compound_instr -> { } .

    ID              reduce using rule 42 (compound_instr -> { } .)
    TYPE            reduce using rule 42 (compound_instr -> { } .)
    error           reduce using rule 42 (compound_instr -> { } .)
    IF              reduce using rule 42 (compound_instr -> { } .)
    WHILE           reduce using rule 42 (compound_instr -> { } .)
    FOR             reduce using rule 42 (compound_instr -> { } .)
    RETURN          reduce using rule 42 (compound_instr -> { } .)
    BREAK           reduce using rule 42 (compound_instr -> { } .)
    CONTINUE        reduce using rule 42 (compound_instr -> { } .)
    {               reduce using rule 42 (compound_instr -> { } .)
    (               reduce using rule 42 (compound_instr -> { } .)
    INTEGER         reduce using rule 42 (compound_instr -> { } .)
    FLOAT           reduce using rule 42 (compound_instr -> { } .)
    STRING          reduce using rule 42 (compound_instr -> { } .)
    $end            reduce using rule 42 (compound_instr -> { } .)
    }               reduce using rule 42 (compound_instr -> { } .)
    ELSE            reduce using rule 42 (compound_instr -> { } .)


state 86

    (9) inits -> inits , init .

    ;               reduce using rule 9 (inits -> inits , init .)
    ,               reduce using rule 9 (inits -> inits , init .)


state 87

    (11) init -> ID . = expression

    =               shift and go to state 50


state 88

    (83) arg -> TYPE . ID

    ID              shift and go to state 131


state 89

    (78) fundef -> TYPE ID ( args_list_or_empty . ) compound_instr

    )               shift and go to state 132


state 90

    (79) args_list_or_empty -> args_list .
    (81) args_list -> args_list . , arg

    )               reduce using rule 79 (args_list_or_empty -> args_list .)
    ,               shift and go to state 133


state 91

    (82) args_list -> arg .

    ,               reduce using rule 82 (args_list -> arg .)
    )               reduce using rule 82 (args_list -> arg .)


state 92

    (11) init -> ID = expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 11 (init -> ID = expression .)
    ,               reduce using rule 11 (init -> ID = expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 93

    (27) labeled_instr -> ID : instruction .

    ID              reduce using rule 27 (labeled_instr -> ID : instruction .)
    TYPE            reduce using rule 27 (labeled_instr -> ID : instruction .)
    error           reduce using rule 27 (labeled_instr -> ID : instruction .)
    IF              reduce using rule 27 (labeled_instr -> ID : instruction .)
    WHILE           reduce using rule 27 (labeled_instr -> ID : instruction .)
    FOR             reduce using rule 27 (labeled_instr -> ID : instruction .)
    RETURN          reduce using rule 27 (labeled_instr -> ID : instruction .)
    BREAK           reduce using rule 27 (labeled_instr -> ID : instruction .)
    CONTINUE        reduce using rule 27 (labeled_instr -> ID : instruction .)
    {               reduce using rule 27 (labeled_instr -> ID : instruction .)
    (               reduce using rule 27 (labeled_instr -> ID : instruction .)
    INTEGER         reduce using rule 27 (labeled_instr -> ID : instruction .)
    FLOAT           reduce using rule 27 (labeled_instr -> ID : instruction .)
    STRING          reduce using rule 27 (labeled_instr -> ID : instruction .)
    $end            reduce using rule 27 (labeled_instr -> ID : instruction .)
    }               reduce using rule 27 (labeled_instr -> ID : instruction .)
    ELSE            reduce using rule 27 (labeled_instr -> ID : instruction .)


state 94

    (28) assignment -> ID = expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 28 (assignment -> ID = expression .)
    )               reduce using rule 28 (assignment -> ID = expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 95

    (29) assignment -> ID = error . ;

    ;               shift and go to state 134


state 96

    (26) statement -> ID ( expr_list_or_empty . ) ;
    (51) expression -> ID ( expr_list_or_empty . )

    )               shift and go to state 135


state 97

    (52) expression -> ID ( error . )

    )               shift and go to state 136


state 98

    (71) expr_list_or_empty -> expr_list .
    (73) expr_list -> expr_list . , expression

    )               reduce using rule 71 (expr_list_or_empty -> expr_list .)
    ,               shift and go to state 137


state 99

    (74) expr_list -> expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ,               reduce using rule 74 (expr_list -> expression .)
    )               reduce using rule 74 (expr_list -> expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 100

    (49) expression -> ( expression ) .

    ;               reduce using rule 49 (expression -> ( expression ) .)
    +               reduce using rule 49 (expression -> ( expression ) .)
    -               reduce using rule 49 (expression -> ( expression ) .)
    *               reduce using rule 49 (expression -> ( expression ) .)
    /               reduce using rule 49 (expression -> ( expression ) .)
    %               reduce using rule 49 (expression -> ( expression ) .)
    |               reduce using rule 49 (expression -> ( expression ) .)
    &               reduce using rule 49 (expression -> ( expression ) .)
    ^               reduce using rule 49 (expression -> ( expression ) .)
    AND             reduce using rule 49 (expression -> ( expression ) .)
    OR              reduce using rule 49 (expression -> ( expression ) .)
    SHL             reduce using rule 49 (expression -> ( expression ) .)
    SHR             reduce using rule 49 (expression -> ( expression ) .)
    EQ              reduce using rule 49 (expression -> ( expression ) .)
    NEQ             reduce using rule 49 (expression -> ( expression ) .)
    >               reduce using rule 49 (expression -> ( expression ) .)
    <               reduce using rule 49 (expression -> ( expression ) .)
    LE              reduce using rule 49 (expression -> ( expression ) .)
    GE              reduce using rule 49 (expression -> ( expression ) .)
    )               reduce using rule 49 (expression -> ( expression ) .)
    ,               reduce using rule 49 (expression -> ( expression ) .)


state 101

    (50) expression -> ( error ) .

    ;               reduce using rule 50 (expression -> ( error ) .)
    +               reduce using rule 50 (expression -> ( error ) .)
    -               reduce using rule 50 (expression -> ( error ) .)
    *               reduce using rule 50 (expression -> ( error ) .)
    /               reduce using rule 50 (expression -> ( error ) .)
    %               reduce using rule 50 (expression -> ( error ) .)
    |               reduce using rule 50 (expression -> ( error ) .)
    &               reduce using rule 50 (expression -> ( error ) .)
    ^               reduce using rule 50 (expression -> ( error ) .)
    AND             reduce using rule 50 (expression -> ( error ) .)
    OR              reduce using rule 50 (expression -> ( error ) .)
    SHL             reduce using rule 50 (expression -> ( error ) .)
    SHR             reduce using rule 50 (expression -> ( error ) .)
    EQ              reduce using rule 50 (expression -> ( error ) .)
    NEQ             reduce using rule 50 (expression -> ( error ) .)
    >               reduce using rule 50 (expression -> ( error ) .)
    <               reduce using rule 50 (expression -> ( error ) .)
    LE              reduce using rule 50 (expression -> ( error ) .)
    GE              reduce using rule 50 (expression -> ( error ) .)
    )               reduce using rule 50 (expression -> ( error ) .)
    ,               reduce using rule 50 (expression -> ( error ) .)


state 102

    (51) expression -> ID ( . expr_list_or_empty )
    (52) expression -> ID ( . error )
    (71) expr_list_or_empty -> . expr_list
    (72) expr_list_or_empty -> .
    (73) expr_list -> . expr_list , expression
    (74) expr_list -> . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    error           shift and go to state 97
    )               reduce using rule 72 (expr_list_or_empty -> .)
    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expr_list_or_empty             shift and go to state 138
    expr_list                      shift and go to state 98
    expression                     shift and go to state 99
    const                          shift and go to state 42

state 103

    (53) expression -> expression + expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 53 (expression -> expression + expression .)
    +               reduce using rule 53 (expression -> expression + expression .)
    -               reduce using rule 53 (expression -> expression + expression .)
    |               reduce using rule 53 (expression -> expression + expression .)
    &               reduce using rule 53 (expression -> expression + expression .)
    ^               reduce using rule 53 (expression -> expression + expression .)
    AND             reduce using rule 53 (expression -> expression + expression .)
    OR              reduce using rule 53 (expression -> expression + expression .)
    SHL             reduce using rule 53 (expression -> expression + expression .)
    SHR             reduce using rule 53 (expression -> expression + expression .)
    EQ              reduce using rule 53 (expression -> expression + expression .)
    NEQ             reduce using rule 53 (expression -> expression + expression .)
    >               reduce using rule 53 (expression -> expression + expression .)
    <               reduce using rule 53 (expression -> expression + expression .)
    LE              reduce using rule 53 (expression -> expression + expression .)
    GE              reduce using rule 53 (expression -> expression + expression .)
    )               reduce using rule 53 (expression -> expression + expression .)
    ,               reduce using rule 53 (expression -> expression + expression .)
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64

  ! *               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! %               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! SHL             [ shift and go to state 70 ]
  ! SHR             [ shift and go to state 71 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 104

    (54) expression -> expression - expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 54 (expression -> expression - expression .)
    +               reduce using rule 54 (expression -> expression - expression .)
    -               reduce using rule 54 (expression -> expression - expression .)
    |               reduce using rule 54 (expression -> expression - expression .)
    &               reduce using rule 54 (expression -> expression - expression .)
    ^               reduce using rule 54 (expression -> expression - expression .)
    AND             reduce using rule 54 (expression -> expression - expression .)
    OR              reduce using rule 54 (expression -> expression - expression .)
    SHL             reduce using rule 54 (expression -> expression - expression .)
    SHR             reduce using rule 54 (expression -> expression - expression .)
    EQ              reduce using rule 54 (expression -> expression - expression .)
    NEQ             reduce using rule 54 (expression -> expression - expression .)
    >               reduce using rule 54 (expression -> expression - expression .)
    <               reduce using rule 54 (expression -> expression - expression .)
    LE              reduce using rule 54 (expression -> expression - expression .)
    GE              reduce using rule 54 (expression -> expression - expression .)
    )               reduce using rule 54 (expression -> expression - expression .)
    ,               reduce using rule 54 (expression -> expression - expression .)
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64

  ! *               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! %               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! SHL             [ shift and go to state 70 ]
  ! SHR             [ shift and go to state 71 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 105

    (55) expression -> expression * expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 55 (expression -> expression * expression .)
    +               reduce using rule 55 (expression -> expression * expression .)
    -               reduce using rule 55 (expression -> expression * expression .)
    *               reduce using rule 55 (expression -> expression * expression .)
    /               reduce using rule 55 (expression -> expression * expression .)
    %               reduce using rule 55 (expression -> expression * expression .)
    |               reduce using rule 55 (expression -> expression * expression .)
    &               reduce using rule 55 (expression -> expression * expression .)
    ^               reduce using rule 55 (expression -> expression * expression .)
    AND             reduce using rule 55 (expression -> expression * expression .)
    OR              reduce using rule 55 (expression -> expression * expression .)
    SHL             reduce using rule 55 (expression -> expression * expression .)
    SHR             reduce using rule 55 (expression -> expression * expression .)
    EQ              reduce using rule 55 (expression -> expression * expression .)
    NEQ             reduce using rule 55 (expression -> expression * expression .)
    >               reduce using rule 55 (expression -> expression * expression .)
    <               reduce using rule 55 (expression -> expression * expression .)
    LE              reduce using rule 55 (expression -> expression * expression .)
    GE              reduce using rule 55 (expression -> expression * expression .)
    )               reduce using rule 55 (expression -> expression * expression .)
    ,               reduce using rule 55 (expression -> expression * expression .)

  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! %               [ shift and go to state 64 ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! SHL             [ shift and go to state 70 ]
  ! SHR             [ shift and go to state 71 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 106

    (56) expression -> expression / expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 56 (expression -> expression / expression .)
    +               reduce using rule 56 (expression -> expression / expression .)
    -               reduce using rule 56 (expression -> expression / expression .)
    *               reduce using rule 56 (expression -> expression / expression .)
    /               reduce using rule 56 (expression -> expression / expression .)
    %               reduce using rule 56 (expression -> expression / expression .)
    |               reduce using rule 56 (expression -> expression / expression .)
    &               reduce using rule 56 (expression -> expression / expression .)
    ^               reduce using rule 56 (expression -> expression / expression .)
    AND             reduce using rule 56 (expression -> expression / expression .)
    OR              reduce using rule 56 (expression -> expression / expression .)
    SHL             reduce using rule 56 (expression -> expression / expression .)
    SHR             reduce using rule 56 (expression -> expression / expression .)
    EQ              reduce using rule 56 (expression -> expression / expression .)
    NEQ             reduce using rule 56 (expression -> expression / expression .)
    >               reduce using rule 56 (expression -> expression / expression .)
    <               reduce using rule 56 (expression -> expression / expression .)
    LE              reduce using rule 56 (expression -> expression / expression .)
    GE              reduce using rule 56 (expression -> expression / expression .)
    )               reduce using rule 56 (expression -> expression / expression .)
    ,               reduce using rule 56 (expression -> expression / expression .)

  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! %               [ shift and go to state 64 ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! SHL             [ shift and go to state 70 ]
  ! SHR             [ shift and go to state 71 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 107

    (57) expression -> expression % expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 57 (expression -> expression % expression .)
    +               reduce using rule 57 (expression -> expression % expression .)
    -               reduce using rule 57 (expression -> expression % expression .)
    *               reduce using rule 57 (expression -> expression % expression .)
    /               reduce using rule 57 (expression -> expression % expression .)
    %               reduce using rule 57 (expression -> expression % expression .)
    |               reduce using rule 57 (expression -> expression % expression .)
    &               reduce using rule 57 (expression -> expression % expression .)
    ^               reduce using rule 57 (expression -> expression % expression .)
    AND             reduce using rule 57 (expression -> expression % expression .)
    OR              reduce using rule 57 (expression -> expression % expression .)
    SHL             reduce using rule 57 (expression -> expression % expression .)
    SHR             reduce using rule 57 (expression -> expression % expression .)
    EQ              reduce using rule 57 (expression -> expression % expression .)
    NEQ             reduce using rule 57 (expression -> expression % expression .)
    >               reduce using rule 57 (expression -> expression % expression .)
    <               reduce using rule 57 (expression -> expression % expression .)
    LE              reduce using rule 57 (expression -> expression % expression .)
    GE              reduce using rule 57 (expression -> expression % expression .)
    )               reduce using rule 57 (expression -> expression % expression .)
    ,               reduce using rule 57 (expression -> expression % expression .)

  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! %               [ shift and go to state 64 ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! SHL             [ shift and go to state 70 ]
  ! SHR             [ shift and go to state 71 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 108

    (58) expression -> expression | expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 58 (expression -> expression | expression .)
    |               reduce using rule 58 (expression -> expression | expression .)
    AND             reduce using rule 58 (expression -> expression | expression .)
    OR              reduce using rule 58 (expression -> expression | expression .)
    )               reduce using rule 58 (expression -> expression | expression .)
    ,               reduce using rule 58 (expression -> expression | expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    &               shift and go to state 66
    ^               shift and go to state 67
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77

  ! +               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! -               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! *               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! /               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! %               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! &               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! ^               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! SHL             [ reduce using rule 58 (expression -> expression | expression .) ]
  ! SHR             [ reduce using rule 58 (expression -> expression | expression .) ]
  ! EQ              [ reduce using rule 58 (expression -> expression | expression .) ]
  ! NEQ             [ reduce using rule 58 (expression -> expression | expression .) ]
  ! >               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! <               [ reduce using rule 58 (expression -> expression | expression .) ]
  ! LE              [ reduce using rule 58 (expression -> expression | expression .) ]
  ! GE              [ reduce using rule 58 (expression -> expression | expression .) ]
  ! |               [ shift and go to state 65 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]


state 109

    (59) expression -> expression & expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 59 (expression -> expression & expression .)
    |               reduce using rule 59 (expression -> expression & expression .)
    &               reduce using rule 59 (expression -> expression & expression .)
    ^               reduce using rule 59 (expression -> expression & expression .)
    AND             reduce using rule 59 (expression -> expression & expression .)
    OR              reduce using rule 59 (expression -> expression & expression .)
    )               reduce using rule 59 (expression -> expression & expression .)
    ,               reduce using rule 59 (expression -> expression & expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77

  ! +               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! -               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! *               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! /               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! %               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! SHL             [ reduce using rule 59 (expression -> expression & expression .) ]
  ! SHR             [ reduce using rule 59 (expression -> expression & expression .) ]
  ! EQ              [ reduce using rule 59 (expression -> expression & expression .) ]
  ! NEQ             [ reduce using rule 59 (expression -> expression & expression .) ]
  ! >               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! <               [ reduce using rule 59 (expression -> expression & expression .) ]
  ! LE              [ reduce using rule 59 (expression -> expression & expression .) ]
  ! GE              [ reduce using rule 59 (expression -> expression & expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]


state 110

    (60) expression -> expression ^ expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 60 (expression -> expression ^ expression .)
    |               reduce using rule 60 (expression -> expression ^ expression .)
    ^               reduce using rule 60 (expression -> expression ^ expression .)
    AND             reduce using rule 60 (expression -> expression ^ expression .)
    OR              reduce using rule 60 (expression -> expression ^ expression .)
    )               reduce using rule 60 (expression -> expression ^ expression .)
    ,               reduce using rule 60 (expression -> expression ^ expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    &               shift and go to state 66
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77

  ! +               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! %               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! &               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! SHL             [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! SHR             [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! EQ              [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! NEQ             [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! >               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! <               [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! LE              [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! GE              [ reduce using rule 60 (expression -> expression ^ expression .) ]
  ! |               [ shift and go to state 65 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]


state 111

    (61) expression -> expression AND expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 61 (expression -> expression AND expression .)
    AND             reduce using rule 61 (expression -> expression AND expression .)
    OR              reduce using rule 61 (expression -> expression AND expression .)
    )               reduce using rule 61 (expression -> expression AND expression .)
    ,               reduce using rule 61 (expression -> expression AND expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77

  ! +               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! %               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! |               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! &               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! ^               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! SHL             [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! SHR             [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 61 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]


state 112

    (62) expression -> expression OR expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 62 (expression -> expression OR expression .)
    OR              reduce using rule 62 (expression -> expression OR expression .)
    )               reduce using rule 62 (expression -> expression OR expression .)
    ,               reduce using rule 62 (expression -> expression OR expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77

  ! +               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! %               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! |               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! &               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! ^               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! SHL             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! SHR             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 62 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 69 ]


state 113

    (63) expression -> expression SHL expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 63 (expression -> expression SHL expression .)
    |               reduce using rule 63 (expression -> expression SHL expression .)
    &               reduce using rule 63 (expression -> expression SHL expression .)
    ^               reduce using rule 63 (expression -> expression SHL expression .)
    AND             reduce using rule 63 (expression -> expression SHL expression .)
    OR              reduce using rule 63 (expression -> expression SHL expression .)
    SHL             reduce using rule 63 (expression -> expression SHL expression .)
    SHR             reduce using rule 63 (expression -> expression SHL expression .)
    EQ              reduce using rule 63 (expression -> expression SHL expression .)
    NEQ             reduce using rule 63 (expression -> expression SHL expression .)
    >               reduce using rule 63 (expression -> expression SHL expression .)
    <               reduce using rule 63 (expression -> expression SHL expression .)
    LE              reduce using rule 63 (expression -> expression SHL expression .)
    GE              reduce using rule 63 (expression -> expression SHL expression .)
    )               reduce using rule 63 (expression -> expression SHL expression .)
    ,               reduce using rule 63 (expression -> expression SHL expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64

  ! +               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! -               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! *               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! /               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! %               [ reduce using rule 63 (expression -> expression SHL expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! SHL             [ shift and go to state 70 ]
  ! SHR             [ shift and go to state 71 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 114

    (64) expression -> expression SHR expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 64 (expression -> expression SHR expression .)
    |               reduce using rule 64 (expression -> expression SHR expression .)
    &               reduce using rule 64 (expression -> expression SHR expression .)
    ^               reduce using rule 64 (expression -> expression SHR expression .)
    AND             reduce using rule 64 (expression -> expression SHR expression .)
    OR              reduce using rule 64 (expression -> expression SHR expression .)
    SHL             reduce using rule 64 (expression -> expression SHR expression .)
    SHR             reduce using rule 64 (expression -> expression SHR expression .)
    EQ              reduce using rule 64 (expression -> expression SHR expression .)
    NEQ             reduce using rule 64 (expression -> expression SHR expression .)
    >               reduce using rule 64 (expression -> expression SHR expression .)
    <               reduce using rule 64 (expression -> expression SHR expression .)
    LE              reduce using rule 64 (expression -> expression SHR expression .)
    GE              reduce using rule 64 (expression -> expression SHR expression .)
    )               reduce using rule 64 (expression -> expression SHR expression .)
    ,               reduce using rule 64 (expression -> expression SHR expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64

  ! +               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! -               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! *               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! /               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! %               [ reduce using rule 64 (expression -> expression SHR expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! SHL             [ shift and go to state 70 ]
  ! SHR             [ shift and go to state 71 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 115

    (65) expression -> expression EQ expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 65 (expression -> expression EQ expression .)
    |               reduce using rule 65 (expression -> expression EQ expression .)
    &               reduce using rule 65 (expression -> expression EQ expression .)
    ^               reduce using rule 65 (expression -> expression EQ expression .)
    AND             reduce using rule 65 (expression -> expression EQ expression .)
    OR              reduce using rule 65 (expression -> expression EQ expression .)
    EQ              reduce using rule 65 (expression -> expression EQ expression .)
    NEQ             reduce using rule 65 (expression -> expression EQ expression .)
    >               reduce using rule 65 (expression -> expression EQ expression .)
    <               reduce using rule 65 (expression -> expression EQ expression .)
    LE              reduce using rule 65 (expression -> expression EQ expression .)
    GE              reduce using rule 65 (expression -> expression EQ expression .)
    )               reduce using rule 65 (expression -> expression EQ expression .)
    ,               reduce using rule 65 (expression -> expression EQ expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    SHL             shift and go to state 70
    SHR             shift and go to state 71

  ! +               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! %               [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! SHL             [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! SHR             [ reduce using rule 65 (expression -> expression EQ expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 116

    (66) expression -> expression NEQ expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 66 (expression -> expression NEQ expression .)
    |               reduce using rule 66 (expression -> expression NEQ expression .)
    &               reduce using rule 66 (expression -> expression NEQ expression .)
    ^               reduce using rule 66 (expression -> expression NEQ expression .)
    AND             reduce using rule 66 (expression -> expression NEQ expression .)
    OR              reduce using rule 66 (expression -> expression NEQ expression .)
    EQ              reduce using rule 66 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 66 (expression -> expression NEQ expression .)
    >               reduce using rule 66 (expression -> expression NEQ expression .)
    <               reduce using rule 66 (expression -> expression NEQ expression .)
    LE              reduce using rule 66 (expression -> expression NEQ expression .)
    GE              reduce using rule 66 (expression -> expression NEQ expression .)
    )               reduce using rule 66 (expression -> expression NEQ expression .)
    ,               reduce using rule 66 (expression -> expression NEQ expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    SHL             shift and go to state 70
    SHR             shift and go to state 71

  ! +               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! %               [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! SHL             [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! SHR             [ reduce using rule 66 (expression -> expression NEQ expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 117

    (67) expression -> expression > expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 67 (expression -> expression > expression .)
    |               reduce using rule 67 (expression -> expression > expression .)
    &               reduce using rule 67 (expression -> expression > expression .)
    ^               reduce using rule 67 (expression -> expression > expression .)
    AND             reduce using rule 67 (expression -> expression > expression .)
    OR              reduce using rule 67 (expression -> expression > expression .)
    EQ              reduce using rule 67 (expression -> expression > expression .)
    NEQ             reduce using rule 67 (expression -> expression > expression .)
    >               reduce using rule 67 (expression -> expression > expression .)
    <               reduce using rule 67 (expression -> expression > expression .)
    LE              reduce using rule 67 (expression -> expression > expression .)
    GE              reduce using rule 67 (expression -> expression > expression .)
    )               reduce using rule 67 (expression -> expression > expression .)
    ,               reduce using rule 67 (expression -> expression > expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    SHL             shift and go to state 70
    SHR             shift and go to state 71

  ! +               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! %               [ reduce using rule 67 (expression -> expression > expression .) ]
  ! SHL             [ reduce using rule 67 (expression -> expression > expression .) ]
  ! SHR             [ reduce using rule 67 (expression -> expression > expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 118

    (68) expression -> expression < expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 68 (expression -> expression < expression .)
    |               reduce using rule 68 (expression -> expression < expression .)
    &               reduce using rule 68 (expression -> expression < expression .)
    ^               reduce using rule 68 (expression -> expression < expression .)
    AND             reduce using rule 68 (expression -> expression < expression .)
    OR              reduce using rule 68 (expression -> expression < expression .)
    EQ              reduce using rule 68 (expression -> expression < expression .)
    NEQ             reduce using rule 68 (expression -> expression < expression .)
    >               reduce using rule 68 (expression -> expression < expression .)
    <               reduce using rule 68 (expression -> expression < expression .)
    LE              reduce using rule 68 (expression -> expression < expression .)
    GE              reduce using rule 68 (expression -> expression < expression .)
    )               reduce using rule 68 (expression -> expression < expression .)
    ,               reduce using rule 68 (expression -> expression < expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    SHL             shift and go to state 70
    SHR             shift and go to state 71

  ! +               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! %               [ reduce using rule 68 (expression -> expression < expression .) ]
  ! SHL             [ reduce using rule 68 (expression -> expression < expression .) ]
  ! SHR             [ reduce using rule 68 (expression -> expression < expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 119

    (69) expression -> expression LE expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 69 (expression -> expression LE expression .)
    |               reduce using rule 69 (expression -> expression LE expression .)
    &               reduce using rule 69 (expression -> expression LE expression .)
    ^               reduce using rule 69 (expression -> expression LE expression .)
    AND             reduce using rule 69 (expression -> expression LE expression .)
    OR              reduce using rule 69 (expression -> expression LE expression .)
    EQ              reduce using rule 69 (expression -> expression LE expression .)
    NEQ             reduce using rule 69 (expression -> expression LE expression .)
    >               reduce using rule 69 (expression -> expression LE expression .)
    <               reduce using rule 69 (expression -> expression LE expression .)
    LE              reduce using rule 69 (expression -> expression LE expression .)
    GE              reduce using rule 69 (expression -> expression LE expression .)
    )               reduce using rule 69 (expression -> expression LE expression .)
    ,               reduce using rule 69 (expression -> expression LE expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    SHL             shift and go to state 70
    SHR             shift and go to state 71

  ! +               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! %               [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! SHL             [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! SHR             [ reduce using rule 69 (expression -> expression LE expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 120

    (70) expression -> expression GE expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               reduce using rule 70 (expression -> expression GE expression .)
    |               reduce using rule 70 (expression -> expression GE expression .)
    &               reduce using rule 70 (expression -> expression GE expression .)
    ^               reduce using rule 70 (expression -> expression GE expression .)
    AND             reduce using rule 70 (expression -> expression GE expression .)
    OR              reduce using rule 70 (expression -> expression GE expression .)
    EQ              reduce using rule 70 (expression -> expression GE expression .)
    NEQ             reduce using rule 70 (expression -> expression GE expression .)
    >               reduce using rule 70 (expression -> expression GE expression .)
    <               reduce using rule 70 (expression -> expression GE expression .)
    LE              reduce using rule 70 (expression -> expression GE expression .)
    GE              reduce using rule 70 (expression -> expression GE expression .)
    )               reduce using rule 70 (expression -> expression GE expression .)
    ,               reduce using rule 70 (expression -> expression GE expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    SHL             shift and go to state 70
    SHR             shift and go to state 71

  ! +               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! %               [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! SHL             [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! SHR             [ reduce using rule 70 (expression -> expression GE expression .) ]
  ! |               [ shift and go to state 65 ]
  ! &               [ shift and go to state 66 ]
  ! ^               [ shift and go to state 67 ]
  ! AND             [ shift and go to state 68 ]
  ! OR              [ shift and go to state 69 ]
  ! EQ              [ shift and go to state 72 ]
  ! NEQ             [ shift and go to state 73 ]
  ! >               [ shift and go to state 74 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 76 ]
  ! GE              [ shift and go to state 77 ]


state 121

    (30) choice_instr -> IF ( condition . ) instruction
    (31) choice_instr -> IF ( condition . ) instruction ELSE instruction

    )               shift and go to state 139


state 122

    (32) choice_instr -> IF ( error . ) instruction
    (33) choice_instr -> IF ( error . ) instruction ELSE instruction

    )               shift and go to state 140


state 123

    (43) condition -> expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    )               reduce using rule 43 (condition -> expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 124

    (34) while_instr -> WHILE ( condition . ) instruction

    )               shift and go to state 141


state 125

    (37) while_instr -> WHILE ( error . ) instruction

    )               shift and go to state 142


state 126

    (35) for_instr -> FOR ( instruction . expression ; assignment ) instruction
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 143
    const                          shift and go to state 42

state 127

    (36) for_instr -> FOR ( error . ) instruction
    (8) declaration -> error . ;

    )               shift and go to state 144
    ;               shift and go to state 16


state 128

    (38) return_instr -> RETURN expression ; .

    ID              reduce using rule 38 (return_instr -> RETURN expression ; .)
    TYPE            reduce using rule 38 (return_instr -> RETURN expression ; .)
    error           reduce using rule 38 (return_instr -> RETURN expression ; .)
    IF              reduce using rule 38 (return_instr -> RETURN expression ; .)
    WHILE           reduce using rule 38 (return_instr -> RETURN expression ; .)
    FOR             reduce using rule 38 (return_instr -> RETURN expression ; .)
    RETURN          reduce using rule 38 (return_instr -> RETURN expression ; .)
    BREAK           reduce using rule 38 (return_instr -> RETURN expression ; .)
    CONTINUE        reduce using rule 38 (return_instr -> RETURN expression ; .)
    {               reduce using rule 38 (return_instr -> RETURN expression ; .)
    (               reduce using rule 38 (return_instr -> RETURN expression ; .)
    INTEGER         reduce using rule 38 (return_instr -> RETURN expression ; .)
    FLOAT           reduce using rule 38 (return_instr -> RETURN expression ; .)
    STRING          reduce using rule 38 (return_instr -> RETURN expression ; .)
    $end            reduce using rule 38 (return_instr -> RETURN expression ; .)
    }               reduce using rule 38 (return_instr -> RETURN expression ; .)
    ELSE            reduce using rule 38 (return_instr -> RETURN expression ; .)


state 129

    (41) compound_instr -> { declarations instructions . }
    (12) instructions -> instructions . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               shift and go to state 145
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! }               [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 51
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 130

    (3) declarations -> declarations declaration .
    (16) instruction -> declaration .

  ! reduce/reduce conflict for } resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for ID resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for TYPE resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for error resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for IF resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for RETURN resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for BREAK resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for { resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for ( resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for INTEGER resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for FLOAT resolved using rule 3 (declarations -> declarations declaration .)
  ! reduce/reduce conflict for STRING resolved using rule 3 (declarations -> declarations declaration .)
    TYPE            reduce using rule 3 (declarations -> declarations declaration .)
    error           reduce using rule 3 (declarations -> declarations declaration .)
    ID              reduce using rule 3 (declarations -> declarations declaration .)
    IF              reduce using rule 3 (declarations -> declarations declaration .)
    WHILE           reduce using rule 3 (declarations -> declarations declaration .)
    FOR             reduce using rule 3 (declarations -> declarations declaration .)
    RETURN          reduce using rule 3 (declarations -> declarations declaration .)
    BREAK           reduce using rule 3 (declarations -> declarations declaration .)
    CONTINUE        reduce using rule 3 (declarations -> declarations declaration .)
    {               reduce using rule 3 (declarations -> declarations declaration .)
    (               reduce using rule 3 (declarations -> declarations declaration .)
    INTEGER         reduce using rule 3 (declarations -> declarations declaration .)
    FLOAT           reduce using rule 3 (declarations -> declarations declaration .)
    STRING          reduce using rule 3 (declarations -> declarations declaration .)
    }               reduce using rule 3 (declarations -> declarations declaration .)

  ! }               [ reduce using rule 16 (instruction -> declaration .) ]
  ! ID              [ reduce using rule 16 (instruction -> declaration .) ]
  ! TYPE            [ reduce using rule 16 (instruction -> declaration .) ]
  ! error           [ reduce using rule 16 (instruction -> declaration .) ]
  ! IF              [ reduce using rule 16 (instruction -> declaration .) ]
  ! WHILE           [ reduce using rule 16 (instruction -> declaration .) ]
  ! FOR             [ reduce using rule 16 (instruction -> declaration .) ]
  ! RETURN          [ reduce using rule 16 (instruction -> declaration .) ]
  ! BREAK           [ reduce using rule 16 (instruction -> declaration .) ]
  ! CONTINUE        [ reduce using rule 16 (instruction -> declaration .) ]
  ! {               [ reduce using rule 16 (instruction -> declaration .) ]
  ! (               [ reduce using rule 16 (instruction -> declaration .) ]
  ! INTEGER         [ reduce using rule 16 (instruction -> declaration .) ]
  ! FLOAT           [ reduce using rule 16 (instruction -> declaration .) ]
  ! STRING          [ reduce using rule 16 (instruction -> declaration .) ]


state 131

    (83) arg -> TYPE ID .

    ,               reduce using rule 83 (arg -> TYPE ID .)
    )               reduce using rule 83 (arg -> TYPE ID .)


state 132

    (78) fundef -> TYPE ID ( args_list_or_empty ) . compound_instr
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }

    {               shift and go to state 41

    compound_instr                 shift and go to state 146

state 133

    (81) args_list -> args_list , . arg
    (83) arg -> . TYPE ID

    TYPE            shift and go to state 88

    arg                            shift and go to state 147

state 134

    (29) assignment -> ID = error ; .

    ;               reduce using rule 29 (assignment -> ID = error ; .)
    )               reduce using rule 29 (assignment -> ID = error ; .)


state 135

    (26) statement -> ID ( expr_list_or_empty ) . ;
    (51) expression -> ID ( expr_list_or_empty ) .

  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 148
    +               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    -               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    *               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    /               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    %               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    |               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    &               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    ^               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    AND             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    OR              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    SHL             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    SHR             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    EQ              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    NEQ             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    >               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    <               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    LE              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    GE              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)

  ! ;               [ reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .) ]


state 136

    (52) expression -> ID ( error ) .

    ;               reduce using rule 52 (expression -> ID ( error ) .)
    +               reduce using rule 52 (expression -> ID ( error ) .)
    -               reduce using rule 52 (expression -> ID ( error ) .)
    *               reduce using rule 52 (expression -> ID ( error ) .)
    /               reduce using rule 52 (expression -> ID ( error ) .)
    %               reduce using rule 52 (expression -> ID ( error ) .)
    |               reduce using rule 52 (expression -> ID ( error ) .)
    &               reduce using rule 52 (expression -> ID ( error ) .)
    ^               reduce using rule 52 (expression -> ID ( error ) .)
    AND             reduce using rule 52 (expression -> ID ( error ) .)
    OR              reduce using rule 52 (expression -> ID ( error ) .)
    SHL             reduce using rule 52 (expression -> ID ( error ) .)
    SHR             reduce using rule 52 (expression -> ID ( error ) .)
    EQ              reduce using rule 52 (expression -> ID ( error ) .)
    NEQ             reduce using rule 52 (expression -> ID ( error ) .)
    >               reduce using rule 52 (expression -> ID ( error ) .)
    <               reduce using rule 52 (expression -> ID ( error ) .)
    LE              reduce using rule 52 (expression -> ID ( error ) .)
    GE              reduce using rule 52 (expression -> ID ( error ) .)
    )               reduce using rule 52 (expression -> ID ( error ) .)
    ,               reduce using rule 52 (expression -> ID ( error ) .)


state 137

    (73) expr_list -> expr_list , . expression
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING

    ID              shift and go to state 57
    (               shift and go to state 22
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

    expression                     shift and go to state 149
    const                          shift and go to state 42

state 138

    (51) expression -> ID ( expr_list_or_empty . )

    )               shift and go to state 150


state 139

    (30) choice_instr -> IF ( condition ) . instruction
    (31) choice_instr -> IF ( condition ) . instruction ELSE instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 151
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 140

    (32) choice_instr -> IF ( error ) . instruction
    (33) choice_instr -> IF ( error ) . instruction ELSE instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 152
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 141

    (34) while_instr -> WHILE ( condition ) . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 153
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 142

    (37) while_instr -> WHILE ( error ) . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 154
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 143

    (35) for_instr -> FOR ( instruction expression . ; assignment ) instruction
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ;               shift and go to state 155
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 144

    (36) for_instr -> FOR ( error ) . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 156
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 145

    (41) compound_instr -> { declarations instructions } .

    ID              reduce using rule 41 (compound_instr -> { declarations instructions } .)
    TYPE            reduce using rule 41 (compound_instr -> { declarations instructions } .)
    error           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    IF              reduce using rule 41 (compound_instr -> { declarations instructions } .)
    WHILE           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    FOR             reduce using rule 41 (compound_instr -> { declarations instructions } .)
    RETURN          reduce using rule 41 (compound_instr -> { declarations instructions } .)
    BREAK           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    CONTINUE        reduce using rule 41 (compound_instr -> { declarations instructions } .)
    {               reduce using rule 41 (compound_instr -> { declarations instructions } .)
    (               reduce using rule 41 (compound_instr -> { declarations instructions } .)
    INTEGER         reduce using rule 41 (compound_instr -> { declarations instructions } .)
    FLOAT           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    STRING          reduce using rule 41 (compound_instr -> { declarations instructions } .)
    $end            reduce using rule 41 (compound_instr -> { declarations instructions } .)
    }               reduce using rule 41 (compound_instr -> { declarations instructions } .)
    ELSE            reduce using rule 41 (compound_instr -> { declarations instructions } .)


state 146

    (78) fundef -> TYPE ID ( args_list_or_empty ) compound_instr .

    TYPE            reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    error           reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    ID              reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    IF              reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    WHILE           reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    FOR             reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    RETURN          reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    BREAK           reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    CONTINUE        reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    {               reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    (               reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    INTEGER         reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    FLOAT           reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    STRING          reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    $end            reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    }               reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    ELSE            reduce using rule 78 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)


state 147

    (81) args_list -> args_list , arg .

    ,               reduce using rule 81 (args_list -> args_list , arg .)
    )               reduce using rule 81 (args_list -> args_list , arg .)


state 148

    (26) statement -> ID ( expr_list_or_empty ) ; .

    ID              reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    TYPE            reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    error           reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    IF              reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    WHILE           reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    FOR             reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    RETURN          reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    BREAK           reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    CONTINUE        reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    {               reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    (               reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    INTEGER         reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    FLOAT           reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    STRING          reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    $end            reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    }               reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)
    ELSE            reduce using rule 26 (statement -> ID ( expr_list_or_empty ) ; .)


state 149

    (73) expr_list -> expr_list , expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . % expression
    (58) expression -> expression . | expression
    (59) expression -> expression . & expression
    (60) expression -> expression . ^ expression
    (61) expression -> expression . AND expression
    (62) expression -> expression . OR expression
    (63) expression -> expression . SHL expression
    (64) expression -> expression . SHR expression
    (65) expression -> expression . EQ expression
    (66) expression -> expression . NEQ expression
    (67) expression -> expression . > expression
    (68) expression -> expression . < expression
    (69) expression -> expression . LE expression
    (70) expression -> expression . GE expression

    ,               reduce using rule 73 (expr_list -> expr_list , expression .)
    )               reduce using rule 73 (expr_list -> expr_list , expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    %               shift and go to state 64
    |               shift and go to state 65
    &               shift and go to state 66
    ^               shift and go to state 67
    AND             shift and go to state 68
    OR              shift and go to state 69
    SHL             shift and go to state 70
    SHR             shift and go to state 71
    EQ              shift and go to state 72
    NEQ             shift and go to state 73
    >               shift and go to state 74
    <               shift and go to state 75
    LE              shift and go to state 76
    GE              shift and go to state 77


state 150

    (51) expression -> ID ( expr_list_or_empty ) .

    )               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    +               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    -               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    *               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    /               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    %               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    |               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    &               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    ^               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    AND             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    OR              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    SHL             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    SHR             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    EQ              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    NEQ             reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    >               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    <               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    LE              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    GE              reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    ;               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)
    ,               reduce using rule 51 (expression -> ID ( expr_list_or_empty ) .)


state 151

    (30) choice_instr -> IF ( condition ) instruction .
    (31) choice_instr -> IF ( condition ) instruction . ELSE instruction

    ID              reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    TYPE            reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    error           reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    IF              reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    WHILE           reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    FOR             reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    RETURN          reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    BREAK           reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    CONTINUE        reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    {               reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    (               reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    INTEGER         reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    FLOAT           reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    STRING          reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    $end            reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    }               reduce using rule 30 (choice_instr -> IF ( condition ) instruction .)
    ELSE            shift and go to state 157

  ! ELSE            [ reduce using rule 30 (choice_instr -> IF ( condition ) instruction .) ]


state 152

    (32) choice_instr -> IF ( error ) instruction .
    (33) choice_instr -> IF ( error ) instruction . ELSE instruction

    ID              reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    TYPE            reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    error           reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    IF              reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    WHILE           reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    FOR             reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    RETURN          reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    BREAK           reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    {               reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    (               reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    INTEGER         reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    FLOAT           reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    STRING          reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    $end            reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    }               reduce using rule 32 (choice_instr -> IF ( error ) instruction .)
    ELSE            shift and go to state 158

  ! ELSE            [ reduce using rule 32 (choice_instr -> IF ( error ) instruction .) ]


state 153

    (34) while_instr -> WHILE ( condition ) instruction .

    ID              reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    TYPE            reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    error           reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    IF              reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    WHILE           reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    FOR             reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    RETURN          reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    BREAK           reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    CONTINUE        reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    {               reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    (               reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    INTEGER         reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    FLOAT           reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    STRING          reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    $end            reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    }               reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)
    ELSE            reduce using rule 34 (while_instr -> WHILE ( condition ) instruction .)


state 154

    (37) while_instr -> WHILE ( error ) instruction .

    ID              reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    TYPE            reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    error           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    IF              reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    FOR             reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    {               reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    (               reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    INTEGER         reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    FLOAT           reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    STRING          reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    $end            reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    }               reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 37 (while_instr -> WHILE ( error ) instruction .)


state 155

    (35) for_instr -> FOR ( instruction expression ; . assignment ) instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;

    ID              shift and go to state 160

    assignment                     shift and go to state 159

state 156

    (36) for_instr -> FOR ( error ) instruction .

    ID              reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    TYPE            reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    error           reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    IF              reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    WHILE           reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    FOR             reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    RETURN          reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    BREAK           reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    CONTINUE        reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    {               reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    (               reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    INTEGER         reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    FLOAT           reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    STRING          reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    $end            reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    }               reduce using rule 36 (for_instr -> FOR ( error ) instruction .)
    ELSE            reduce using rule 36 (for_instr -> FOR ( error ) instruction .)


state 157

    (31) choice_instr -> IF ( condition ) instruction ELSE . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 161
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 158

    (33) choice_instr -> IF ( error ) instruction ELSE . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 162
    labeled_instr                  shift and go to state 24
    assignment                     shift and go to state 25
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    expression                     shift and go to state 34
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 159

    (35) for_instr -> FOR ( instruction expression ; assignment . ) instruction

    )               shift and go to state 163


state 160

    (28) assignment -> ID . = expression
    (29) assignment -> ID . = error ;

    =               shift and go to state 53


state 161

    (31) choice_instr -> IF ( condition ) instruction ELSE instruction .

    ID              reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    TYPE            reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    error           reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    IF              reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    WHILE           reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    FOR             reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    RETURN          reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    BREAK           reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    {               reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    (               reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    INTEGER         reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    FLOAT           reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    STRING          reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    $end            reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    }               reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ELSE            reduce using rule 31 (choice_instr -> IF ( condition ) instruction ELSE instruction .)


state 162

    (33) choice_instr -> IF ( error ) instruction ELSE instruction .

    ID              reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    TYPE            reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    error           reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    FOR             reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    {               reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    (               reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    INTEGER         reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    FLOAT           reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    STRING          reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 33 (choice_instr -> IF ( error ) instruction ELSE instruction .)


state 163

    (35) for_instr -> FOR ( instruction expression ; assignment ) . instruction
    (14) instruction -> . labeled_instr
    (15) instruction -> . assignment ;
    (16) instruction -> . declaration
    (17) instruction -> . choice_instr
    (18) instruction -> . while_instr
    (19) instruction -> . for_instr
    (20) instruction -> . return_instr
    (21) instruction -> . break_instr
    (22) instruction -> . continue_instr
    (23) instruction -> . compound_instr
    (24) instruction -> . statement
    (25) instruction -> . expression ;
    (27) labeled_instr -> . ID : instruction
    (28) assignment -> . ID = expression
    (29) assignment -> . ID = error ;
    (6) declaration -> . fundefs
    (7) declaration -> . TYPE inits ;
    (8) declaration -> . error ;
    (30) choice_instr -> . IF ( condition ) instruction
    (31) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (32) choice_instr -> . IF ( error ) instruction
    (33) choice_instr -> . IF ( error ) instruction ELSE instruction
    (34) while_instr -> . WHILE ( condition ) instruction
    (37) while_instr -> . WHILE ( error ) instruction
    (35) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (36) for_instr -> . FOR ( error ) instruction
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }
    (42) compound_instr -> . { }
    (26) statement -> . ID ( expr_list_or_empty ) ;
    (47) expression -> . const
    (48) expression -> . ID
    (49) expression -> . ( expression )
    (50) expression -> . ( error )
    (51) expression -> . ID ( expr_list_or_empty )
    (52) expression -> . ID ( error )
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression % expression
    (58) expression -> . expression | expression
    (59) expression -> . expression & expression
    (60) expression -> . expression ^ expression
    (61) expression -> . expression AND expression
    (62) expression -> . expression OR expression
    (63) expression -> . expression SHL expression
    (64) expression -> . expression SHR expression
    (65) expression -> . expression EQ expression
    (66) expression -> . expression NEQ expression
    (67) expression -> . expression > expression
    (68) expression -> . expression < expression
    (69) expression -> . expression LE expression
    (70) expression -> . expression GE expression
    (75) fundefs -> . fundefs fundef
    (76) fundefs -> . fundef
    (77) fundefs -> .
    (44) const -> . INTEGER
    (45) const -> . FLOAT
    (46) const -> . STRING
    (78) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 21
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 35
    WHILE           shift and go to state 36
    FOR             shift and go to state 37
    RETURN          shift and go to state 38
    BREAK           shift and go to state 39
    CONTINUE        shift and go to state 40
    {               shift and go to state 41
    (               shift and go to state 22
    $end            reduce using rule 77 (fundefs -> .)
    }               reduce using rule 77 (fundefs -> .)
    ELSE            reduce using rule 77 (fundefs -> .)
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    STRING          shift and go to state 45

  ! TYPE            [ reduce using rule 77 (fundefs -> .) ]
  ! ID              [ reduce using rule 77 (fundefs -> .) ]
  ! error           [ reduce using rule 77 (fundefs -> .) ]
  ! IF              [ reduce using rule 77 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 77 (fundefs -> .) ]
  ! FOR             [ reduce using rule 77 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 77 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 77 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 77 (fundefs -> .) ]
  ! {               [ reduce using rule 77 (fundefs -> .) ]
  ! (               [ reduce using rule 77 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 77 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 77 (fundefs -> .) ]
  ! STRING          [ reduce using rule 77 (fundefs -> .) ]

    instruction                    shift and go to state 164
    expression                     shift and go to state 34
    assignment                     shift and go to state 25
    labeled_instr                  shift and go to state 24
    declaration                    shift and go to state 26
    choice_instr                   shift and go to state 27
    while_instr                    shift and go to state 28
    for_instr                      shift and go to state 29
    return_instr                   shift and go to state 30
    break_instr                    shift and go to state 31
    continue_instr                 shift and go to state 32
    compound_instr                 shift and go to state 23
    statement                      shift and go to state 33
    fundefs                        shift and go to state 3
    const                          shift and go to state 42
    fundef                         shift and go to state 8

state 164

    (35) for_instr -> FOR ( instruction expression ; assignment ) instruction .

    ID              reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    TYPE            reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    error           reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    IF              reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    WHILE           reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    FOR             reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    RETURN          reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    BREAK           reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    CONTINUE        reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    {               reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    (               reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    INTEGER         reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    FLOAT           reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    STRING          reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    $end            reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    }               reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    ELSE            reduce using rule 35 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for error in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for error in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 3 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 4 resolved as shift
WARNING: shift/reduce conflict for error in state 4 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 4 resolved as shift
WARNING: shift/reduce conflict for error in state 4 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 9 resolved as shift
WARNING: shift/reduce conflict for ID in state 9 resolved as shift
WARNING: shift/reduce conflict for error in state 9 resolved as shift
WARNING: shift/reduce conflict for IF in state 9 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 9 resolved as shift
WARNING: shift/reduce conflict for FOR in state 9 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 9 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 9 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 9 resolved as shift
WARNING: shift/reduce conflict for { in state 9 resolved as shift
WARNING: shift/reduce conflict for ( in state 9 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 9 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 9 resolved as shift
WARNING: shift/reduce conflict for STRING in state 9 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 17 resolved as shift
WARNING: shift/reduce conflict for ID in state 17 resolved as shift
WARNING: shift/reduce conflict for error in state 17 resolved as shift
WARNING: shift/reduce conflict for IF in state 17 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 17 resolved as shift
WARNING: shift/reduce conflict for FOR in state 17 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 17 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 17 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 17 resolved as shift
WARNING: shift/reduce conflict for { in state 17 resolved as shift
WARNING: shift/reduce conflict for ( in state 17 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 17 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 17 resolved as shift
WARNING: shift/reduce conflict for STRING in state 17 resolved as shift
WARNING: shift/reduce conflict for } in state 41 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 41 resolved as shift
WARNING: shift/reduce conflict for error in state 41 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 41 resolved as shift
WARNING: shift/reduce conflict for error in state 41 resolved as shift
WARNING: shift/reduce conflict for } in state 41 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 52 resolved as shift
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for error in state 52 resolved as shift
WARNING: shift/reduce conflict for IF in state 52 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 52 resolved as shift
WARNING: shift/reduce conflict for FOR in state 52 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 52 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 52 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 52 resolved as shift
WARNING: shift/reduce conflict for { in state 52 resolved as shift
WARNING: shift/reduce conflict for ( in state 52 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 52 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 52 resolved as shift
WARNING: shift/reduce conflict for STRING in state 52 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 80 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for ( in state 80 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 80 resolved as shift
WARNING: shift/reduce conflict for STRING in state 80 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 84 resolved as shift
WARNING: shift/reduce conflict for error in state 84 resolved as shift
WARNING: shift/reduce conflict for ID in state 84 resolved as shift
WARNING: shift/reduce conflict for IF in state 84 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 84 resolved as shift
WARNING: shift/reduce conflict for FOR in state 84 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 84 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 84 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 84 resolved as shift
WARNING: shift/reduce conflict for { in state 84 resolved as shift
WARNING: shift/reduce conflict for ( in state 84 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 84 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 84 resolved as shift
WARNING: shift/reduce conflict for STRING in state 84 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 129 resolved as shift
WARNING: shift/reduce conflict for } in state 129 resolved as shift
WARNING: shift/reduce conflict for ID in state 129 resolved as shift
WARNING: shift/reduce conflict for error in state 129 resolved as shift
WARNING: shift/reduce conflict for IF in state 129 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 129 resolved as shift
WARNING: shift/reduce conflict for FOR in state 129 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 129 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 129 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 129 resolved as shift
WARNING: shift/reduce conflict for { in state 129 resolved as shift
WARNING: shift/reduce conflict for ( in state 129 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 129 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 129 resolved as shift
WARNING: shift/reduce conflict for STRING in state 129 resolved as shift
WARNING: shift/reduce conflict for ; in state 135 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 139 resolved as shift
WARNING: shift/reduce conflict for ID in state 139 resolved as shift
WARNING: shift/reduce conflict for error in state 139 resolved as shift
WARNING: shift/reduce conflict for IF in state 139 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 139 resolved as shift
WARNING: shift/reduce conflict for FOR in state 139 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 139 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 139 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 139 resolved as shift
WARNING: shift/reduce conflict for { in state 139 resolved as shift
WARNING: shift/reduce conflict for ( in state 139 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 139 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 139 resolved as shift
WARNING: shift/reduce conflict for STRING in state 139 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for ID in state 140 resolved as shift
WARNING: shift/reduce conflict for error in state 140 resolved as shift
WARNING: shift/reduce conflict for IF in state 140 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 140 resolved as shift
WARNING: shift/reduce conflict for FOR in state 140 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 140 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 140 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 140 resolved as shift
WARNING: shift/reduce conflict for { in state 140 resolved as shift
WARNING: shift/reduce conflict for ( in state 140 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 140 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 140 resolved as shift
WARNING: shift/reduce conflict for STRING in state 140 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 141 resolved as shift
WARNING: shift/reduce conflict for ID in state 141 resolved as shift
WARNING: shift/reduce conflict for error in state 141 resolved as shift
WARNING: shift/reduce conflict for IF in state 141 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 141 resolved as shift
WARNING: shift/reduce conflict for FOR in state 141 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 141 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 141 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 141 resolved as shift
WARNING: shift/reduce conflict for { in state 141 resolved as shift
WARNING: shift/reduce conflict for ( in state 141 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 141 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 141 resolved as shift
WARNING: shift/reduce conflict for STRING in state 141 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for ID in state 142 resolved as shift
WARNING: shift/reduce conflict for error in state 142 resolved as shift
WARNING: shift/reduce conflict for IF in state 142 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 142 resolved as shift
WARNING: shift/reduce conflict for FOR in state 142 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 142 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 142 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 142 resolved as shift
WARNING: shift/reduce conflict for { in state 142 resolved as shift
WARNING: shift/reduce conflict for ( in state 142 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 142 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 142 resolved as shift
WARNING: shift/reduce conflict for STRING in state 142 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for ID in state 144 resolved as shift
WARNING: shift/reduce conflict for error in state 144 resolved as shift
WARNING: shift/reduce conflict for IF in state 144 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 144 resolved as shift
WARNING: shift/reduce conflict for FOR in state 144 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 144 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 144 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 144 resolved as shift
WARNING: shift/reduce conflict for { in state 144 resolved as shift
WARNING: shift/reduce conflict for ( in state 144 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 144 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 144 resolved as shift
WARNING: shift/reduce conflict for STRING in state 144 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for error in state 157 resolved as shift
WARNING: shift/reduce conflict for IF in state 157 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 157 resolved as shift
WARNING: shift/reduce conflict for FOR in state 157 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 157 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 157 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 157 resolved as shift
WARNING: shift/reduce conflict for { in state 157 resolved as shift
WARNING: shift/reduce conflict for ( in state 157 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 157 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 157 resolved as shift
WARNING: shift/reduce conflict for STRING in state 157 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for error in state 158 resolved as shift
WARNING: shift/reduce conflict for IF in state 158 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 158 resolved as shift
WARNING: shift/reduce conflict for FOR in state 158 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 158 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 158 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 158 resolved as shift
WARNING: shift/reduce conflict for { in state 158 resolved as shift
WARNING: shift/reduce conflict for ( in state 158 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 158 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 158 resolved as shift
WARNING: shift/reduce conflict for STRING in state 158 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 163 resolved as shift
WARNING: shift/reduce conflict for ID in state 163 resolved as shift
WARNING: shift/reduce conflict for error in state 163 resolved as shift
WARNING: shift/reduce conflict for IF in state 163 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 163 resolved as shift
WARNING: shift/reduce conflict for FOR in state 163 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 163 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 163 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 163 resolved as shift
WARNING: shift/reduce conflict for { in state 163 resolved as shift
WARNING: shift/reduce conflict for ( in state 163 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 163 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 163 resolved as shift
WARNING: shift/reduce conflict for STRING in state 163 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (declarations -> <empty>)
WARNING: rejected rule (fundefs -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 4 resolved using rule (ext_declarations -> declarations)
WARNING: rejected rule (fundefs -> <empty>) in state 4
WARNING: reduce/reduce conflict in state 17 resolved using rule (program -> ext_declarations fundefs instructions)
WARNING: rejected rule (fundefs -> <empty>) in state 17
WARNING: reduce/reduce conflict in state 18 resolved using rule (fundefs -> fundefs fundef)
WARNING: rejected rule (fundefs -> fundef) in state 18
WARNING: reduce/reduce conflict in state 41 resolved using rule (declarations -> <empty>)
WARNING: rejected rule (fundefs -> <empty>) in state 41
WARNING: reduce/reduce conflict in state 130 resolved using rule (declarations -> declarations declaration)
WARNING: rejected rule (instruction -> declaration) in state 130
