Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> ext_declarations
Rule 2     ext_declarations -> declarations
Rule 3     array -> [ INTEGER ]
Rule 4     declarations -> declarations declaration
Rule 5     declarations -> declaration
Rule 6     declarations -> <empty>
Rule 7     declaration -> fundefs
Rule 8     declaration -> TYPE inits ;
Rule 9     declaration -> error ;
Rule 10    inits -> inits , init
Rule 11    inits -> init
Rule 12    init -> ID = expression
Rule 13    init -> ID
Rule 14    init -> ID array
Rule 15    init -> * ID
Rule 16    init -> * ID = expression
Rule 17    instructions -> instructions instruction
Rule 18    instructions -> instruction
Rule 19    instruction -> labeled_instr
Rule 20    instruction -> assignment ;
Rule 21    instruction -> declaration
Rule 22    instruction -> choice_instr
Rule 23    instruction -> while_instr
Rule 24    instruction -> for_instr
Rule 25    instruction -> return_instr
Rule 26    instruction -> break_instr
Rule 27    instruction -> continue_instr
Rule 28    instruction -> compound_instr
Rule 29    instruction -> statement
Rule 30    instruction -> expression ;
Rule 31    statement -> ID ( expr_list_or_empty ) ;
Rule 32    labeled_instr -> ID : instruction
Rule 33    assignment -> ID = expression
Rule 34    assignment -> ID array = expression
Rule 35    assignment -> ID = error ;
Rule 36    choice_instr -> IF ( condition ) instruction
Rule 37    choice_instr -> IF ( condition ) instruction ELSE instruction
Rule 38    choice_instr -> IF ( error ) instruction
Rule 39    choice_instr -> IF ( error ) instruction ELSE instruction
Rule 40    while_instr -> WHILE ( condition ) instruction
Rule 41    for_instr -> FOR ( instruction expression ; assignment ) instruction
Rule 42    for_instr -> FOR ( error ) instruction
Rule 43    while_instr -> WHILE ( error ) instruction
Rule 44    return_instr -> RETURN expression ;
Rule 45    continue_instr -> CONTINUE ;
Rule 46    break_instr -> BREAK ;
Rule 47    compound_instr -> { instructions }
Rule 48    compound_instr -> { }
Rule 49    condition -> expression
Rule 50    const -> INTEGER
Rule 51    const -> FLOAT
Rule 52    const -> STRING
Rule 53    expression -> const
Rule 54    expression -> ID
Rule 55    expression -> & ID
Rule 56    expression -> * ID
Rule 57    expression -> ID array
Rule 58    expression -> ( expression )
Rule 59    expression -> ( error )
Rule 60    expression -> ID ( expr_list_or_empty )
Rule 61    expression -> ID ( error )
Rule 62    expression -> expression + expression
Rule 63    expression -> expression - expression
Rule 64    expression -> expression * expression
Rule 65    expression -> expression / expression
Rule 66    expression -> expression % expression
Rule 67    expression -> expression | expression
Rule 68    expression -> expression & expression
Rule 69    expression -> expression ^ expression
Rule 70    expression -> expression AND expression
Rule 71    expression -> expression OR expression
Rule 72    expression -> expression SHL expression
Rule 73    expression -> expression SHR expression
Rule 74    expression -> expression EQ expression
Rule 75    expression -> expression NEQ expression
Rule 76    expression -> expression > expression
Rule 77    expression -> expression < expression
Rule 78    expression -> expression LE expression
Rule 79    expression -> expression GE expression
Rule 80    expr_list_or_empty -> expr_list
Rule 81    expr_list_or_empty -> <empty>
Rule 82    expr_list -> expr_list , expression
Rule 83    expr_list -> expression
Rule 84    fundefs -> fundefs fundef
Rule 85    fundefs -> fundef
Rule 86    fundefs -> <empty>
Rule 87    fundef -> TYPE ID ( args_list_or_empty ) compound_instr
Rule 88    args_list_or_empty -> args_list
Rule 89    args_list_or_empty -> <empty>
Rule 90    args_list -> args_list , arg
Rule 91    args_list -> arg
Rule 92    arg -> TYPE ID

Terminals, with rules where they appear

%                    : 66
&                    : 55 68
(                    : 31 36 37 38 39 40 41 42 43 58 59 60 61 87
)                    : 31 36 37 38 39 40 41 42 43 58 59 60 61 87
*                    : 15 16 56 64
+                    : 62
,                    : 10 82 90
-                    : 63
/                    : 65
:                    : 32
;                    : 8 9 20 30 31 35 41 44 45 46
<                    : 77
=                    : 12 16 33 34 35
>                    : 76
AND                  : 70
BREAK                : 46
CONTINUE             : 45
ELSE                 : 37 39
EQ                   : 74
FLOAT                : 51
FOR                  : 41 42
GE                   : 79
ID                   : 12 13 14 15 16 31 32 33 34 35 54 55 56 57 60 61 87 92
IF                   : 36 37 38 39
INTEGER              : 3 50
LE                   : 78
NEQ                  : 75
OR                   : 71
RETURN               : 44
SHL                  : 72
SHR                  : 73
STRING               : 52
TYPE                 : 8 87 92
WHILE                : 40 43
[                    : 3
]                    : 3
^                    : 69
error                : 9 35 38 39 42 43 59 61
{                    : 47 48
|                    : 67
}                    : 47 48

Nonterminals, with rules where they appear

arg                  : 90 91
args_list            : 88 90
args_list_or_empty   : 87
array                : 14 34 57
assignment           : 20 41
break_instr          : 26
choice_instr         : 22
compound_instr       : 28 87
condition            : 36 37 40
const                : 53
continue_instr       : 27
declaration          : 4 5 21
declarations         : 2 4
expr_list            : 80 82
expr_list_or_empty   : 31 60
expression           : 12 16 30 33 34 41 44 49 58 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 79 82 83
ext_declarations     : 1
for_instr            : 24
fundef               : 84 85
fundefs              : 7 84
init                 : 10 11
inits                : 8 10
instruction          : 17 18 32 36 37 37 38 39 39 40 41 41 42 43
instructions         : 17 47
labeled_instr        : 19
program              : 0
return_instr         : 25
statement            : 29
while_instr          : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . ext_declarations
    (2) ext_declarations -> . declarations
    (4) declarations -> . declarations declaration
    (5) declarations -> . declaration
    (6) declarations -> .
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 6 (declarations -> .)
    $end            reduce using rule 6 (declarations -> .)
    TYPE            shift and go to state 6
    error           shift and go to state 7

  ! TYPE            [ reduce using rule 6 (declarations -> .) ]
  ! error           [ reduce using rule 6 (declarations -> .) ]
  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! $end            [ reduce using rule 86 (fundefs -> .) ]

    program                        shift and go to state 1
    ext_declarations               shift and go to state 2
    declarations                   shift and go to state 3
    declaration                    shift and go to state 4
    fundefs                        shift and go to state 5
    fundef                         shift and go to state 8

state 1

    (0) S' -> program .



state 2

    (1) program -> ext_declarations .

    $end            reduce using rule 1 (program -> ext_declarations .)


state 3

    (2) ext_declarations -> declarations .
    (4) declarations -> declarations . declaration
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 2 (ext_declarations -> declarations .)
    $end            reduce using rule 2 (ext_declarations -> declarations .)
    TYPE            shift and go to state 6
    error           shift and go to state 7

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! $end            [ reduce using rule 86 (fundefs -> .) ]

    declaration                    shift and go to state 9
    fundefs                        shift and go to state 5
    fundef                         shift and go to state 8

state 4

    (5) declarations -> declaration .

    TYPE            reduce using rule 5 (declarations -> declaration .)
    error           reduce using rule 5 (declarations -> declaration .)
    $end            reduce using rule 5 (declarations -> declaration .)


state 5

    (7) declaration -> fundefs .
    (84) fundefs -> fundefs . fundef
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
    error           reduce using rule 7 (declaration -> fundefs .)
    $end            reduce using rule 7 (declaration -> fundefs .)
    }               reduce using rule 7 (declaration -> fundefs .)
    ID              reduce using rule 7 (declaration -> fundefs .)
    IF              reduce using rule 7 (declaration -> fundefs .)
    WHILE           reduce using rule 7 (declaration -> fundefs .)
    FOR             reduce using rule 7 (declaration -> fundefs .)
    RETURN          reduce using rule 7 (declaration -> fundefs .)
    BREAK           reduce using rule 7 (declaration -> fundefs .)
    CONTINUE        reduce using rule 7 (declaration -> fundefs .)
    {               reduce using rule 7 (declaration -> fundefs .)
    &               reduce using rule 7 (declaration -> fundefs .)
    *               reduce using rule 7 (declaration -> fundefs .)
    (               reduce using rule 7 (declaration -> fundefs .)
    INTEGER         reduce using rule 7 (declaration -> fundefs .)
    FLOAT           reduce using rule 7 (declaration -> fundefs .)
    STRING          reduce using rule 7 (declaration -> fundefs .)
    ELSE            reduce using rule 7 (declaration -> fundefs .)
    TYPE            shift and go to state 11

  ! TYPE            [ reduce using rule 7 (declaration -> fundefs .) ]

    fundef                         shift and go to state 10

state 6

    (8) declaration -> TYPE . inits ;
    (87) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr
    (10) inits -> . inits , init
    (11) inits -> . init
    (12) init -> . ID = expression
    (13) init -> . ID
    (14) init -> . ID array
    (15) init -> . * ID
    (16) init -> . * ID = expression

    ID              shift and go to state 13
    *               shift and go to state 15

    inits                          shift and go to state 12
    init                           shift and go to state 14

state 7

    (9) declaration -> error . ;

    ;               shift and go to state 16


state 8

    (85) fundefs -> fundef .

    TYPE            reduce using rule 85 (fundefs -> fundef .)
    error           reduce using rule 85 (fundefs -> fundef .)
    $end            reduce using rule 85 (fundefs -> fundef .)
    }               reduce using rule 85 (fundefs -> fundef .)
    ID              reduce using rule 85 (fundefs -> fundef .)
    IF              reduce using rule 85 (fundefs -> fundef .)
    WHILE           reduce using rule 85 (fundefs -> fundef .)
    FOR             reduce using rule 85 (fundefs -> fundef .)
    RETURN          reduce using rule 85 (fundefs -> fundef .)
    BREAK           reduce using rule 85 (fundefs -> fundef .)
    CONTINUE        reduce using rule 85 (fundefs -> fundef .)
    {               reduce using rule 85 (fundefs -> fundef .)
    &               reduce using rule 85 (fundefs -> fundef .)
    *               reduce using rule 85 (fundefs -> fundef .)
    (               reduce using rule 85 (fundefs -> fundef .)
    INTEGER         reduce using rule 85 (fundefs -> fundef .)
    FLOAT           reduce using rule 85 (fundefs -> fundef .)
    STRING          reduce using rule 85 (fundefs -> fundef .)
    ELSE            reduce using rule 85 (fundefs -> fundef .)


state 9

    (4) declarations -> declarations declaration .

    TYPE            reduce using rule 4 (declarations -> declarations declaration .)
    error           reduce using rule 4 (declarations -> declarations declaration .)
    $end            reduce using rule 4 (declarations -> declarations declaration .)


state 10

    (84) fundefs -> fundefs fundef .

    TYPE            reduce using rule 84 (fundefs -> fundefs fundef .)
    error           reduce using rule 84 (fundefs -> fundefs fundef .)
    $end            reduce using rule 84 (fundefs -> fundefs fundef .)
    }               reduce using rule 84 (fundefs -> fundefs fundef .)
    ID              reduce using rule 84 (fundefs -> fundefs fundef .)
    IF              reduce using rule 84 (fundefs -> fundefs fundef .)
    WHILE           reduce using rule 84 (fundefs -> fundefs fundef .)
    FOR             reduce using rule 84 (fundefs -> fundefs fundef .)
    RETURN          reduce using rule 84 (fundefs -> fundefs fundef .)
    BREAK           reduce using rule 84 (fundefs -> fundefs fundef .)
    CONTINUE        reduce using rule 84 (fundefs -> fundefs fundef .)
    {               reduce using rule 84 (fundefs -> fundefs fundef .)
    &               reduce using rule 84 (fundefs -> fundefs fundef .)
    *               reduce using rule 84 (fundefs -> fundefs fundef .)
    (               reduce using rule 84 (fundefs -> fundefs fundef .)
    INTEGER         reduce using rule 84 (fundefs -> fundefs fundef .)
    FLOAT           reduce using rule 84 (fundefs -> fundefs fundef .)
    STRING          reduce using rule 84 (fundefs -> fundefs fundef .)
    ELSE            reduce using rule 84 (fundefs -> fundefs fundef .)


state 11

    (87) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr

    ID              shift and go to state 17


state 12

    (8) declaration -> TYPE inits . ;
    (10) inits -> inits . , init

    ;               shift and go to state 18
    ,               shift and go to state 19


state 13

    (87) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr
    (12) init -> ID . = expression
    (13) init -> ID .
    (14) init -> ID . array
    (3) array -> . [ INTEGER ]

    (               shift and go to state 20
    =               shift and go to state 21
    ;               reduce using rule 13 (init -> ID .)
    ,               reduce using rule 13 (init -> ID .)
    [               shift and go to state 23

    array                          shift and go to state 22

state 14

    (11) inits -> init .

    ;               reduce using rule 11 (inits -> init .)
    ,               reduce using rule 11 (inits -> init .)


state 15

    (15) init -> * . ID
    (16) init -> * . ID = expression

    ID              shift and go to state 24


state 16

    (9) declaration -> error ; .

    TYPE            reduce using rule 9 (declaration -> error ; .)
    error           reduce using rule 9 (declaration -> error ; .)
    $end            reduce using rule 9 (declaration -> error ; .)
    }               reduce using rule 9 (declaration -> error ; .)
    ID              reduce using rule 9 (declaration -> error ; .)
    IF              reduce using rule 9 (declaration -> error ; .)
    WHILE           reduce using rule 9 (declaration -> error ; .)
    FOR             reduce using rule 9 (declaration -> error ; .)
    RETURN          reduce using rule 9 (declaration -> error ; .)
    BREAK           reduce using rule 9 (declaration -> error ; .)
    CONTINUE        reduce using rule 9 (declaration -> error ; .)
    {               reduce using rule 9 (declaration -> error ; .)
    &               reduce using rule 9 (declaration -> error ; .)
    *               reduce using rule 9 (declaration -> error ; .)
    (               reduce using rule 9 (declaration -> error ; .)
    INTEGER         reduce using rule 9 (declaration -> error ; .)
    FLOAT           reduce using rule 9 (declaration -> error ; .)
    STRING          reduce using rule 9 (declaration -> error ; .)
    ELSE            reduce using rule 9 (declaration -> error ; .)


state 17

    (87) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr

    (               shift and go to state 20


state 18

    (8) declaration -> TYPE inits ; .

    TYPE            reduce using rule 8 (declaration -> TYPE inits ; .)
    error           reduce using rule 8 (declaration -> TYPE inits ; .)
    $end            reduce using rule 8 (declaration -> TYPE inits ; .)
    }               reduce using rule 8 (declaration -> TYPE inits ; .)
    ID              reduce using rule 8 (declaration -> TYPE inits ; .)
    IF              reduce using rule 8 (declaration -> TYPE inits ; .)
    WHILE           reduce using rule 8 (declaration -> TYPE inits ; .)
    FOR             reduce using rule 8 (declaration -> TYPE inits ; .)
    RETURN          reduce using rule 8 (declaration -> TYPE inits ; .)
    BREAK           reduce using rule 8 (declaration -> TYPE inits ; .)
    CONTINUE        reduce using rule 8 (declaration -> TYPE inits ; .)
    {               reduce using rule 8 (declaration -> TYPE inits ; .)
    &               reduce using rule 8 (declaration -> TYPE inits ; .)
    *               reduce using rule 8 (declaration -> TYPE inits ; .)
    (               reduce using rule 8 (declaration -> TYPE inits ; .)
    INTEGER         reduce using rule 8 (declaration -> TYPE inits ; .)
    FLOAT           reduce using rule 8 (declaration -> TYPE inits ; .)
    STRING          reduce using rule 8 (declaration -> TYPE inits ; .)
    ELSE            reduce using rule 8 (declaration -> TYPE inits ; .)


state 19

    (10) inits -> inits , . init
    (12) init -> . ID = expression
    (13) init -> . ID
    (14) init -> . ID array
    (15) init -> . * ID
    (16) init -> . * ID = expression

    ID              shift and go to state 26
    *               shift and go to state 15

    init                           shift and go to state 25

state 20

    (87) fundef -> TYPE ID ( . args_list_or_empty ) compound_instr
    (88) args_list_or_empty -> . args_list
    (89) args_list_or_empty -> .
    (90) args_list -> . args_list , arg
    (91) args_list -> . arg
    (92) arg -> . TYPE ID

    )               reduce using rule 89 (args_list_or_empty -> .)
    TYPE            shift and go to state 27

    args_list_or_empty             shift and go to state 28
    args_list                      shift and go to state 29
    arg                            shift and go to state 30

state 21

    (12) init -> ID = . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 32
    const                          shift and go to state 33

state 22

    (14) init -> ID array .

    ;               reduce using rule 14 (init -> ID array .)
    ,               reduce using rule 14 (init -> ID array .)


state 23

    (3) array -> [ . INTEGER ]

    INTEGER         shift and go to state 40


state 24

    (15) init -> * ID .
    (16) init -> * ID . = expression

    ;               reduce using rule 15 (init -> * ID .)
    ,               reduce using rule 15 (init -> * ID .)
    =               shift and go to state 41


state 25

    (10) inits -> inits , init .

    ;               reduce using rule 10 (inits -> inits , init .)
    ,               reduce using rule 10 (inits -> inits , init .)


state 26

    (12) init -> ID . = expression
    (13) init -> ID .
    (14) init -> ID . array
    (3) array -> . [ INTEGER ]

    =               shift and go to state 21
    ;               reduce using rule 13 (init -> ID .)
    ,               reduce using rule 13 (init -> ID .)
    [               shift and go to state 23

    array                          shift and go to state 22

state 27

    (92) arg -> TYPE . ID

    ID              shift and go to state 42


state 28

    (87) fundef -> TYPE ID ( args_list_or_empty . ) compound_instr

    )               shift and go to state 43


state 29

    (88) args_list_or_empty -> args_list .
    (90) args_list -> args_list . , arg

    )               reduce using rule 88 (args_list_or_empty -> args_list .)
    ,               shift and go to state 44


state 30

    (91) args_list -> arg .

    ,               reduce using rule 91 (args_list -> arg .)
    )               reduce using rule 91 (args_list -> arg .)


state 31

    (54) expression -> ID .
    (57) expression -> ID . array
    (60) expression -> ID . ( expr_list_or_empty )
    (61) expression -> ID . ( error )
    (3) array -> . [ INTEGER ]

    +               reduce using rule 54 (expression -> ID .)
    -               reduce using rule 54 (expression -> ID .)
    *               reduce using rule 54 (expression -> ID .)
    /               reduce using rule 54 (expression -> ID .)
    %               reduce using rule 54 (expression -> ID .)
    |               reduce using rule 54 (expression -> ID .)
    &               reduce using rule 54 (expression -> ID .)
    ^               reduce using rule 54 (expression -> ID .)
    AND             reduce using rule 54 (expression -> ID .)
    OR              reduce using rule 54 (expression -> ID .)
    SHL             reduce using rule 54 (expression -> ID .)
    SHR             reduce using rule 54 (expression -> ID .)
    EQ              reduce using rule 54 (expression -> ID .)
    NEQ             reduce using rule 54 (expression -> ID .)
    >               reduce using rule 54 (expression -> ID .)
    <               reduce using rule 54 (expression -> ID .)
    LE              reduce using rule 54 (expression -> ID .)
    GE              reduce using rule 54 (expression -> ID .)
    ;               reduce using rule 54 (expression -> ID .)
    ,               reduce using rule 54 (expression -> ID .)
    )               reduce using rule 54 (expression -> ID .)
    (               shift and go to state 46
    [               shift and go to state 23

    array                          shift and go to state 45

state 32

    (12) init -> ID = expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ;               reduce using rule 12 (init -> ID = expression .)
    ,               reduce using rule 12 (init -> ID = expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 33

    (53) expression -> const .

    +               reduce using rule 53 (expression -> const .)
    -               reduce using rule 53 (expression -> const .)
    *               reduce using rule 53 (expression -> const .)
    /               reduce using rule 53 (expression -> const .)
    %               reduce using rule 53 (expression -> const .)
    |               reduce using rule 53 (expression -> const .)
    &               reduce using rule 53 (expression -> const .)
    ^               reduce using rule 53 (expression -> const .)
    AND             reduce using rule 53 (expression -> const .)
    OR              reduce using rule 53 (expression -> const .)
    SHL             reduce using rule 53 (expression -> const .)
    SHR             reduce using rule 53 (expression -> const .)
    EQ              reduce using rule 53 (expression -> const .)
    NEQ             reduce using rule 53 (expression -> const .)
    >               reduce using rule 53 (expression -> const .)
    <               reduce using rule 53 (expression -> const .)
    LE              reduce using rule 53 (expression -> const .)
    GE              reduce using rule 53 (expression -> const .)
    ;               reduce using rule 53 (expression -> const .)
    ,               reduce using rule 53 (expression -> const .)
    )               reduce using rule 53 (expression -> const .)


state 34

    (55) expression -> & . ID

    ID              shift and go to state 65


state 35

    (56) expression -> * . ID

    ID              shift and go to state 66


state 36

    (58) expression -> ( . expression )
    (59) expression -> ( . error )
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    error           shift and go to state 68
    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 67
    const                          shift and go to state 33

state 37

    (50) const -> INTEGER .

    +               reduce using rule 50 (const -> INTEGER .)
    -               reduce using rule 50 (const -> INTEGER .)
    *               reduce using rule 50 (const -> INTEGER .)
    /               reduce using rule 50 (const -> INTEGER .)
    %               reduce using rule 50 (const -> INTEGER .)
    |               reduce using rule 50 (const -> INTEGER .)
    &               reduce using rule 50 (const -> INTEGER .)
    ^               reduce using rule 50 (const -> INTEGER .)
    AND             reduce using rule 50 (const -> INTEGER .)
    OR              reduce using rule 50 (const -> INTEGER .)
    SHL             reduce using rule 50 (const -> INTEGER .)
    SHR             reduce using rule 50 (const -> INTEGER .)
    EQ              reduce using rule 50 (const -> INTEGER .)
    NEQ             reduce using rule 50 (const -> INTEGER .)
    >               reduce using rule 50 (const -> INTEGER .)
    <               reduce using rule 50 (const -> INTEGER .)
    LE              reduce using rule 50 (const -> INTEGER .)
    GE              reduce using rule 50 (const -> INTEGER .)
    ;               reduce using rule 50 (const -> INTEGER .)
    ,               reduce using rule 50 (const -> INTEGER .)
    )               reduce using rule 50 (const -> INTEGER .)


state 38

    (51) const -> FLOAT .

    +               reduce using rule 51 (const -> FLOAT .)
    -               reduce using rule 51 (const -> FLOAT .)
    *               reduce using rule 51 (const -> FLOAT .)
    /               reduce using rule 51 (const -> FLOAT .)
    %               reduce using rule 51 (const -> FLOAT .)
    |               reduce using rule 51 (const -> FLOAT .)
    &               reduce using rule 51 (const -> FLOAT .)
    ^               reduce using rule 51 (const -> FLOAT .)
    AND             reduce using rule 51 (const -> FLOAT .)
    OR              reduce using rule 51 (const -> FLOAT .)
    SHL             reduce using rule 51 (const -> FLOAT .)
    SHR             reduce using rule 51 (const -> FLOAT .)
    EQ              reduce using rule 51 (const -> FLOAT .)
    NEQ             reduce using rule 51 (const -> FLOAT .)
    >               reduce using rule 51 (const -> FLOAT .)
    <               reduce using rule 51 (const -> FLOAT .)
    LE              reduce using rule 51 (const -> FLOAT .)
    GE              reduce using rule 51 (const -> FLOAT .)
    ;               reduce using rule 51 (const -> FLOAT .)
    ,               reduce using rule 51 (const -> FLOAT .)
    )               reduce using rule 51 (const -> FLOAT .)


state 39

    (52) const -> STRING .

    +               reduce using rule 52 (const -> STRING .)
    -               reduce using rule 52 (const -> STRING .)
    *               reduce using rule 52 (const -> STRING .)
    /               reduce using rule 52 (const -> STRING .)
    %               reduce using rule 52 (const -> STRING .)
    |               reduce using rule 52 (const -> STRING .)
    &               reduce using rule 52 (const -> STRING .)
    ^               reduce using rule 52 (const -> STRING .)
    AND             reduce using rule 52 (const -> STRING .)
    OR              reduce using rule 52 (const -> STRING .)
    SHL             reduce using rule 52 (const -> STRING .)
    SHR             reduce using rule 52 (const -> STRING .)
    EQ              reduce using rule 52 (const -> STRING .)
    NEQ             reduce using rule 52 (const -> STRING .)
    >               reduce using rule 52 (const -> STRING .)
    <               reduce using rule 52 (const -> STRING .)
    LE              reduce using rule 52 (const -> STRING .)
    GE              reduce using rule 52 (const -> STRING .)
    ;               reduce using rule 52 (const -> STRING .)
    ,               reduce using rule 52 (const -> STRING .)
    )               reduce using rule 52 (const -> STRING .)


state 40

    (3) array -> [ INTEGER . ]

    ]               shift and go to state 69


state 41

    (16) init -> * ID = . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 70
    const                          shift and go to state 33

state 42

    (92) arg -> TYPE ID .

    ,               reduce using rule 92 (arg -> TYPE ID .)
    )               reduce using rule 92 (arg -> TYPE ID .)


state 43

    (87) fundef -> TYPE ID ( args_list_or_empty ) . compound_instr
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }

    {               shift and go to state 72

    compound_instr                 shift and go to state 71

state 44

    (90) args_list -> args_list , . arg
    (92) arg -> . TYPE ID

    TYPE            shift and go to state 27

    arg                            shift and go to state 73

state 45

    (57) expression -> ID array .

    +               reduce using rule 57 (expression -> ID array .)
    -               reduce using rule 57 (expression -> ID array .)
    *               reduce using rule 57 (expression -> ID array .)
    /               reduce using rule 57 (expression -> ID array .)
    %               reduce using rule 57 (expression -> ID array .)
    |               reduce using rule 57 (expression -> ID array .)
    &               reduce using rule 57 (expression -> ID array .)
    ^               reduce using rule 57 (expression -> ID array .)
    AND             reduce using rule 57 (expression -> ID array .)
    OR              reduce using rule 57 (expression -> ID array .)
    SHL             reduce using rule 57 (expression -> ID array .)
    SHR             reduce using rule 57 (expression -> ID array .)
    EQ              reduce using rule 57 (expression -> ID array .)
    NEQ             reduce using rule 57 (expression -> ID array .)
    >               reduce using rule 57 (expression -> ID array .)
    <               reduce using rule 57 (expression -> ID array .)
    LE              reduce using rule 57 (expression -> ID array .)
    GE              reduce using rule 57 (expression -> ID array .)
    ;               reduce using rule 57 (expression -> ID array .)
    ,               reduce using rule 57 (expression -> ID array .)
    )               reduce using rule 57 (expression -> ID array .)


state 46

    (60) expression -> ID ( . expr_list_or_empty )
    (61) expression -> ID ( . error )
    (80) expr_list_or_empty -> . expr_list
    (81) expr_list_or_empty -> .
    (82) expr_list -> . expr_list , expression
    (83) expr_list -> . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    error           shift and go to state 75
    )               reduce using rule 81 (expr_list_or_empty -> .)
    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expr_list_or_empty             shift and go to state 74
    expr_list                      shift and go to state 76
    expression                     shift and go to state 77
    const                          shift and go to state 33

state 47

    (62) expression -> expression + . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 78
    const                          shift and go to state 33

state 48

    (63) expression -> expression - . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 79
    const                          shift and go to state 33

state 49

    (64) expression -> expression * . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 80
    const                          shift and go to state 33

state 50

    (65) expression -> expression / . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 81
    const                          shift and go to state 33

state 51

    (66) expression -> expression % . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 82
    const                          shift and go to state 33

state 52

    (67) expression -> expression | . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 83
    const                          shift and go to state 33

state 53

    (68) expression -> expression & . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 84
    const                          shift and go to state 33

state 54

    (69) expression -> expression ^ . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 85
    const                          shift and go to state 33

state 55

    (70) expression -> expression AND . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 86
    const                          shift and go to state 33

state 56

    (71) expression -> expression OR . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 87
    const                          shift and go to state 33

state 57

    (72) expression -> expression SHL . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 88
    const                          shift and go to state 33

state 58

    (73) expression -> expression SHR . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 89
    const                          shift and go to state 33

state 59

    (74) expression -> expression EQ . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 90
    const                          shift and go to state 33

state 60

    (75) expression -> expression NEQ . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 91
    const                          shift and go to state 33

state 61

    (76) expression -> expression > . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 92
    const                          shift and go to state 33

state 62

    (77) expression -> expression < . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 93
    const                          shift and go to state 33

state 63

    (78) expression -> expression LE . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 94
    const                          shift and go to state 33

state 64

    (79) expression -> expression GE . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 95
    const                          shift and go to state 33

state 65

    (55) expression -> & ID .

    +               reduce using rule 55 (expression -> & ID .)
    -               reduce using rule 55 (expression -> & ID .)
    *               reduce using rule 55 (expression -> & ID .)
    /               reduce using rule 55 (expression -> & ID .)
    %               reduce using rule 55 (expression -> & ID .)
    |               reduce using rule 55 (expression -> & ID .)
    &               reduce using rule 55 (expression -> & ID .)
    ^               reduce using rule 55 (expression -> & ID .)
    AND             reduce using rule 55 (expression -> & ID .)
    OR              reduce using rule 55 (expression -> & ID .)
    SHL             reduce using rule 55 (expression -> & ID .)
    SHR             reduce using rule 55 (expression -> & ID .)
    EQ              reduce using rule 55 (expression -> & ID .)
    NEQ             reduce using rule 55 (expression -> & ID .)
    >               reduce using rule 55 (expression -> & ID .)
    <               reduce using rule 55 (expression -> & ID .)
    LE              reduce using rule 55 (expression -> & ID .)
    GE              reduce using rule 55 (expression -> & ID .)
    ;               reduce using rule 55 (expression -> & ID .)
    ,               reduce using rule 55 (expression -> & ID .)
    )               reduce using rule 55 (expression -> & ID .)


state 66

    (56) expression -> * ID .

    +               reduce using rule 56 (expression -> * ID .)
    -               reduce using rule 56 (expression -> * ID .)
    *               reduce using rule 56 (expression -> * ID .)
    /               reduce using rule 56 (expression -> * ID .)
    %               reduce using rule 56 (expression -> * ID .)
    |               reduce using rule 56 (expression -> * ID .)
    &               reduce using rule 56 (expression -> * ID .)
    ^               reduce using rule 56 (expression -> * ID .)
    AND             reduce using rule 56 (expression -> * ID .)
    OR              reduce using rule 56 (expression -> * ID .)
    SHL             reduce using rule 56 (expression -> * ID .)
    SHR             reduce using rule 56 (expression -> * ID .)
    EQ              reduce using rule 56 (expression -> * ID .)
    NEQ             reduce using rule 56 (expression -> * ID .)
    >               reduce using rule 56 (expression -> * ID .)
    <               reduce using rule 56 (expression -> * ID .)
    LE              reduce using rule 56 (expression -> * ID .)
    GE              reduce using rule 56 (expression -> * ID .)
    ;               reduce using rule 56 (expression -> * ID .)
    ,               reduce using rule 56 (expression -> * ID .)
    )               reduce using rule 56 (expression -> * ID .)


state 67

    (58) expression -> ( expression . )
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    )               shift and go to state 96
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 68

    (59) expression -> ( error . )

    )               shift and go to state 97


state 69

    (3) array -> [ INTEGER ] .

    ;               reduce using rule 3 (array -> [ INTEGER ] .)
    ,               reduce using rule 3 (array -> [ INTEGER ] .)
    +               reduce using rule 3 (array -> [ INTEGER ] .)
    -               reduce using rule 3 (array -> [ INTEGER ] .)
    *               reduce using rule 3 (array -> [ INTEGER ] .)
    /               reduce using rule 3 (array -> [ INTEGER ] .)
    %               reduce using rule 3 (array -> [ INTEGER ] .)
    |               reduce using rule 3 (array -> [ INTEGER ] .)
    &               reduce using rule 3 (array -> [ INTEGER ] .)
    ^               reduce using rule 3 (array -> [ INTEGER ] .)
    AND             reduce using rule 3 (array -> [ INTEGER ] .)
    OR              reduce using rule 3 (array -> [ INTEGER ] .)
    SHL             reduce using rule 3 (array -> [ INTEGER ] .)
    SHR             reduce using rule 3 (array -> [ INTEGER ] .)
    EQ              reduce using rule 3 (array -> [ INTEGER ] .)
    NEQ             reduce using rule 3 (array -> [ INTEGER ] .)
    >               reduce using rule 3 (array -> [ INTEGER ] .)
    <               reduce using rule 3 (array -> [ INTEGER ] .)
    LE              reduce using rule 3 (array -> [ INTEGER ] .)
    GE              reduce using rule 3 (array -> [ INTEGER ] .)
    )               reduce using rule 3 (array -> [ INTEGER ] .)
    =               reduce using rule 3 (array -> [ INTEGER ] .)


state 70

    (16) init -> * ID = expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ;               reduce using rule 16 (init -> * ID = expression .)
    ,               reduce using rule 16 (init -> * ID = expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 71

    (87) fundef -> TYPE ID ( args_list_or_empty ) compound_instr .

    TYPE            reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    error           reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    $end            reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    }               reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    ID              reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    IF              reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    WHILE           reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    FOR             reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    RETURN          reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    BREAK           reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    CONTINUE        reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    {               reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    &               reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    *               reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    (               reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    INTEGER         reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    FLOAT           reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    STRING          reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    ELSE            reduce using rule 87 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)


state 72

    (47) compound_instr -> { . instructions }
    (48) compound_instr -> { . }
    (17) instructions -> . instructions instruction
    (18) instructions -> . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               shift and go to state 99
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! }               [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instructions                   shift and go to state 98
    instruction                    shift and go to state 100
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 73

    (90) args_list -> args_list , arg .

    ,               reduce using rule 90 (args_list -> args_list , arg .)
    )               reduce using rule 90 (args_list -> args_list , arg .)


state 74

    (60) expression -> ID ( expr_list_or_empty . )

    )               shift and go to state 120


state 75

    (61) expression -> ID ( error . )

    )               shift and go to state 121


state 76

    (80) expr_list_or_empty -> expr_list .
    (82) expr_list -> expr_list . , expression

    )               reduce using rule 80 (expr_list_or_empty -> expr_list .)
    ,               shift and go to state 122


state 77

    (83) expr_list -> expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ,               reduce using rule 83 (expr_list -> expression .)
    )               reduce using rule 83 (expr_list -> expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 78

    (62) expression -> expression + expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    +               reduce using rule 62 (expression -> expression + expression .)
    -               reduce using rule 62 (expression -> expression + expression .)
    |               reduce using rule 62 (expression -> expression + expression .)
    &               reduce using rule 62 (expression -> expression + expression .)
    ^               reduce using rule 62 (expression -> expression + expression .)
    AND             reduce using rule 62 (expression -> expression + expression .)
    OR              reduce using rule 62 (expression -> expression + expression .)
    SHL             reduce using rule 62 (expression -> expression + expression .)
    SHR             reduce using rule 62 (expression -> expression + expression .)
    EQ              reduce using rule 62 (expression -> expression + expression .)
    NEQ             reduce using rule 62 (expression -> expression + expression .)
    >               reduce using rule 62 (expression -> expression + expression .)
    <               reduce using rule 62 (expression -> expression + expression .)
    LE              reduce using rule 62 (expression -> expression + expression .)
    GE              reduce using rule 62 (expression -> expression + expression .)
    ;               reduce using rule 62 (expression -> expression + expression .)
    ,               reduce using rule 62 (expression -> expression + expression .)
    )               reduce using rule 62 (expression -> expression + expression .)
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51

  ! *               [ reduce using rule 62 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 62 (expression -> expression + expression .) ]
  ! %               [ reduce using rule 62 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 48 ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! SHL             [ shift and go to state 57 ]
  ! SHR             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 79

    (63) expression -> expression - expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    +               reduce using rule 63 (expression -> expression - expression .)
    -               reduce using rule 63 (expression -> expression - expression .)
    |               reduce using rule 63 (expression -> expression - expression .)
    &               reduce using rule 63 (expression -> expression - expression .)
    ^               reduce using rule 63 (expression -> expression - expression .)
    AND             reduce using rule 63 (expression -> expression - expression .)
    OR              reduce using rule 63 (expression -> expression - expression .)
    SHL             reduce using rule 63 (expression -> expression - expression .)
    SHR             reduce using rule 63 (expression -> expression - expression .)
    EQ              reduce using rule 63 (expression -> expression - expression .)
    NEQ             reduce using rule 63 (expression -> expression - expression .)
    >               reduce using rule 63 (expression -> expression - expression .)
    <               reduce using rule 63 (expression -> expression - expression .)
    LE              reduce using rule 63 (expression -> expression - expression .)
    GE              reduce using rule 63 (expression -> expression - expression .)
    ;               reduce using rule 63 (expression -> expression - expression .)
    ,               reduce using rule 63 (expression -> expression - expression .)
    )               reduce using rule 63 (expression -> expression - expression .)
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51

  ! *               [ reduce using rule 63 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 63 (expression -> expression - expression .) ]
  ! %               [ reduce using rule 63 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 48 ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! SHL             [ shift and go to state 57 ]
  ! SHR             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 80

    (64) expression -> expression * expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    +               reduce using rule 64 (expression -> expression * expression .)
    -               reduce using rule 64 (expression -> expression * expression .)
    *               reduce using rule 64 (expression -> expression * expression .)
    /               reduce using rule 64 (expression -> expression * expression .)
    %               reduce using rule 64 (expression -> expression * expression .)
    |               reduce using rule 64 (expression -> expression * expression .)
    &               reduce using rule 64 (expression -> expression * expression .)
    ^               reduce using rule 64 (expression -> expression * expression .)
    AND             reduce using rule 64 (expression -> expression * expression .)
    OR              reduce using rule 64 (expression -> expression * expression .)
    SHL             reduce using rule 64 (expression -> expression * expression .)
    SHR             reduce using rule 64 (expression -> expression * expression .)
    EQ              reduce using rule 64 (expression -> expression * expression .)
    NEQ             reduce using rule 64 (expression -> expression * expression .)
    >               reduce using rule 64 (expression -> expression * expression .)
    <               reduce using rule 64 (expression -> expression * expression .)
    LE              reduce using rule 64 (expression -> expression * expression .)
    GE              reduce using rule 64 (expression -> expression * expression .)
    ;               reduce using rule 64 (expression -> expression * expression .)
    ,               reduce using rule 64 (expression -> expression * expression .)
    )               reduce using rule 64 (expression -> expression * expression .)

  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 48 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 50 ]
  ! %               [ shift and go to state 51 ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! SHL             [ shift and go to state 57 ]
  ! SHR             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 81

    (65) expression -> expression / expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    +               reduce using rule 65 (expression -> expression / expression .)
    -               reduce using rule 65 (expression -> expression / expression .)
    *               reduce using rule 65 (expression -> expression / expression .)
    /               reduce using rule 65 (expression -> expression / expression .)
    %               reduce using rule 65 (expression -> expression / expression .)
    |               reduce using rule 65 (expression -> expression / expression .)
    &               reduce using rule 65 (expression -> expression / expression .)
    ^               reduce using rule 65 (expression -> expression / expression .)
    AND             reduce using rule 65 (expression -> expression / expression .)
    OR              reduce using rule 65 (expression -> expression / expression .)
    SHL             reduce using rule 65 (expression -> expression / expression .)
    SHR             reduce using rule 65 (expression -> expression / expression .)
    EQ              reduce using rule 65 (expression -> expression / expression .)
    NEQ             reduce using rule 65 (expression -> expression / expression .)
    >               reduce using rule 65 (expression -> expression / expression .)
    <               reduce using rule 65 (expression -> expression / expression .)
    LE              reduce using rule 65 (expression -> expression / expression .)
    GE              reduce using rule 65 (expression -> expression / expression .)
    ;               reduce using rule 65 (expression -> expression / expression .)
    ,               reduce using rule 65 (expression -> expression / expression .)
    )               reduce using rule 65 (expression -> expression / expression .)

  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 48 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 50 ]
  ! %               [ shift and go to state 51 ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! SHL             [ shift and go to state 57 ]
  ! SHR             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 82

    (66) expression -> expression % expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    +               reduce using rule 66 (expression -> expression % expression .)
    -               reduce using rule 66 (expression -> expression % expression .)
    *               reduce using rule 66 (expression -> expression % expression .)
    /               reduce using rule 66 (expression -> expression % expression .)
    %               reduce using rule 66 (expression -> expression % expression .)
    |               reduce using rule 66 (expression -> expression % expression .)
    &               reduce using rule 66 (expression -> expression % expression .)
    ^               reduce using rule 66 (expression -> expression % expression .)
    AND             reduce using rule 66 (expression -> expression % expression .)
    OR              reduce using rule 66 (expression -> expression % expression .)
    SHL             reduce using rule 66 (expression -> expression % expression .)
    SHR             reduce using rule 66 (expression -> expression % expression .)
    EQ              reduce using rule 66 (expression -> expression % expression .)
    NEQ             reduce using rule 66 (expression -> expression % expression .)
    >               reduce using rule 66 (expression -> expression % expression .)
    <               reduce using rule 66 (expression -> expression % expression .)
    LE              reduce using rule 66 (expression -> expression % expression .)
    GE              reduce using rule 66 (expression -> expression % expression .)
    ;               reduce using rule 66 (expression -> expression % expression .)
    ,               reduce using rule 66 (expression -> expression % expression .)
    )               reduce using rule 66 (expression -> expression % expression .)

  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 48 ]
  ! *               [ shift and go to state 49 ]
  ! /               [ shift and go to state 50 ]
  ! %               [ shift and go to state 51 ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! SHL             [ shift and go to state 57 ]
  ! SHR             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 83

    (67) expression -> expression | expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 67 (expression -> expression | expression .)
    AND             reduce using rule 67 (expression -> expression | expression .)
    OR              reduce using rule 67 (expression -> expression | expression .)
    ;               reduce using rule 67 (expression -> expression | expression .)
    ,               reduce using rule 67 (expression -> expression | expression .)
    )               reduce using rule 67 (expression -> expression | expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    &               shift and go to state 53
    ^               shift and go to state 54
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64

  ! +               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! -               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! *               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! /               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! %               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! &               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! ^               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! SHL             [ reduce using rule 67 (expression -> expression | expression .) ]
  ! SHR             [ reduce using rule 67 (expression -> expression | expression .) ]
  ! EQ              [ reduce using rule 67 (expression -> expression | expression .) ]
  ! NEQ             [ reduce using rule 67 (expression -> expression | expression .) ]
  ! >               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! <               [ reduce using rule 67 (expression -> expression | expression .) ]
  ! LE              [ reduce using rule 67 (expression -> expression | expression .) ]
  ! GE              [ reduce using rule 67 (expression -> expression | expression .) ]
  ! |               [ shift and go to state 52 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]


state 84

    (68) expression -> expression & expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 68 (expression -> expression & expression .)
    &               reduce using rule 68 (expression -> expression & expression .)
    ^               reduce using rule 68 (expression -> expression & expression .)
    AND             reduce using rule 68 (expression -> expression & expression .)
    OR              reduce using rule 68 (expression -> expression & expression .)
    ;               reduce using rule 68 (expression -> expression & expression .)
    ,               reduce using rule 68 (expression -> expression & expression .)
    )               reduce using rule 68 (expression -> expression & expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64

  ! +               [ reduce using rule 68 (expression -> expression & expression .) ]
  ! -               [ reduce using rule 68 (expression -> expression & expression .) ]
  ! *               [ reduce using rule 68 (expression -> expression & expression .) ]
  ! /               [ reduce using rule 68 (expression -> expression & expression .) ]
  ! %               [ reduce using rule 68 (expression -> expression & expression .) ]
  ! SHL             [ reduce using rule 68 (expression -> expression & expression .) ]
  ! SHR             [ reduce using rule 68 (expression -> expression & expression .) ]
  ! EQ              [ reduce using rule 68 (expression -> expression & expression .) ]
  ! NEQ             [ reduce using rule 68 (expression -> expression & expression .) ]
  ! >               [ reduce using rule 68 (expression -> expression & expression .) ]
  ! <               [ reduce using rule 68 (expression -> expression & expression .) ]
  ! LE              [ reduce using rule 68 (expression -> expression & expression .) ]
  ! GE              [ reduce using rule 68 (expression -> expression & expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]


state 85

    (69) expression -> expression ^ expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 69 (expression -> expression ^ expression .)
    ^               reduce using rule 69 (expression -> expression ^ expression .)
    AND             reduce using rule 69 (expression -> expression ^ expression .)
    OR              reduce using rule 69 (expression -> expression ^ expression .)
    ;               reduce using rule 69 (expression -> expression ^ expression .)
    ,               reduce using rule 69 (expression -> expression ^ expression .)
    )               reduce using rule 69 (expression -> expression ^ expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    &               shift and go to state 53
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64

  ! +               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! %               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! &               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! SHL             [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! SHR             [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! EQ              [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! NEQ             [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! >               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! <               [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! LE              [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! GE              [ reduce using rule 69 (expression -> expression ^ expression .) ]
  ! |               [ shift and go to state 52 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]


state 86

    (70) expression -> expression AND expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    AND             reduce using rule 70 (expression -> expression AND expression .)
    OR              reduce using rule 70 (expression -> expression AND expression .)
    ;               reduce using rule 70 (expression -> expression AND expression .)
    ,               reduce using rule 70 (expression -> expression AND expression .)
    )               reduce using rule 70 (expression -> expression AND expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64

  ! +               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! %               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! |               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! &               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! ^               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! SHL             [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! SHR             [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 70 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]


state 87

    (71) expression -> expression OR expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    OR              reduce using rule 71 (expression -> expression OR expression .)
    ;               reduce using rule 71 (expression -> expression OR expression .)
    ,               reduce using rule 71 (expression -> expression OR expression .)
    )               reduce using rule 71 (expression -> expression OR expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64

  ! +               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! %               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! |               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! &               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! ^               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! SHL             [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! SHR             [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 71 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 56 ]


state 88

    (72) expression -> expression SHL expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 72 (expression -> expression SHL expression .)
    &               reduce using rule 72 (expression -> expression SHL expression .)
    ^               reduce using rule 72 (expression -> expression SHL expression .)
    AND             reduce using rule 72 (expression -> expression SHL expression .)
    OR              reduce using rule 72 (expression -> expression SHL expression .)
    SHL             reduce using rule 72 (expression -> expression SHL expression .)
    SHR             reduce using rule 72 (expression -> expression SHL expression .)
    EQ              reduce using rule 72 (expression -> expression SHL expression .)
    NEQ             reduce using rule 72 (expression -> expression SHL expression .)
    >               reduce using rule 72 (expression -> expression SHL expression .)
    <               reduce using rule 72 (expression -> expression SHL expression .)
    LE              reduce using rule 72 (expression -> expression SHL expression .)
    GE              reduce using rule 72 (expression -> expression SHL expression .)
    ;               reduce using rule 72 (expression -> expression SHL expression .)
    ,               reduce using rule 72 (expression -> expression SHL expression .)
    )               reduce using rule 72 (expression -> expression SHL expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51

  ! +               [ reduce using rule 72 (expression -> expression SHL expression .) ]
  ! -               [ reduce using rule 72 (expression -> expression SHL expression .) ]
  ! *               [ reduce using rule 72 (expression -> expression SHL expression .) ]
  ! /               [ reduce using rule 72 (expression -> expression SHL expression .) ]
  ! %               [ reduce using rule 72 (expression -> expression SHL expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! SHL             [ shift and go to state 57 ]
  ! SHR             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 89

    (73) expression -> expression SHR expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 73 (expression -> expression SHR expression .)
    &               reduce using rule 73 (expression -> expression SHR expression .)
    ^               reduce using rule 73 (expression -> expression SHR expression .)
    AND             reduce using rule 73 (expression -> expression SHR expression .)
    OR              reduce using rule 73 (expression -> expression SHR expression .)
    SHL             reduce using rule 73 (expression -> expression SHR expression .)
    SHR             reduce using rule 73 (expression -> expression SHR expression .)
    EQ              reduce using rule 73 (expression -> expression SHR expression .)
    NEQ             reduce using rule 73 (expression -> expression SHR expression .)
    >               reduce using rule 73 (expression -> expression SHR expression .)
    <               reduce using rule 73 (expression -> expression SHR expression .)
    LE              reduce using rule 73 (expression -> expression SHR expression .)
    GE              reduce using rule 73 (expression -> expression SHR expression .)
    ;               reduce using rule 73 (expression -> expression SHR expression .)
    ,               reduce using rule 73 (expression -> expression SHR expression .)
    )               reduce using rule 73 (expression -> expression SHR expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51

  ! +               [ reduce using rule 73 (expression -> expression SHR expression .) ]
  ! -               [ reduce using rule 73 (expression -> expression SHR expression .) ]
  ! *               [ reduce using rule 73 (expression -> expression SHR expression .) ]
  ! /               [ reduce using rule 73 (expression -> expression SHR expression .) ]
  ! %               [ reduce using rule 73 (expression -> expression SHR expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! SHL             [ shift and go to state 57 ]
  ! SHR             [ shift and go to state 58 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 90

    (74) expression -> expression EQ expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 74 (expression -> expression EQ expression .)
    &               reduce using rule 74 (expression -> expression EQ expression .)
    ^               reduce using rule 74 (expression -> expression EQ expression .)
    AND             reduce using rule 74 (expression -> expression EQ expression .)
    OR              reduce using rule 74 (expression -> expression EQ expression .)
    EQ              reduce using rule 74 (expression -> expression EQ expression .)
    NEQ             reduce using rule 74 (expression -> expression EQ expression .)
    >               reduce using rule 74 (expression -> expression EQ expression .)
    <               reduce using rule 74 (expression -> expression EQ expression .)
    LE              reduce using rule 74 (expression -> expression EQ expression .)
    GE              reduce using rule 74 (expression -> expression EQ expression .)
    ;               reduce using rule 74 (expression -> expression EQ expression .)
    ,               reduce using rule 74 (expression -> expression EQ expression .)
    )               reduce using rule 74 (expression -> expression EQ expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    SHL             shift and go to state 57
    SHR             shift and go to state 58

  ! +               [ reduce using rule 74 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 74 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 74 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 74 (expression -> expression EQ expression .) ]
  ! %               [ reduce using rule 74 (expression -> expression EQ expression .) ]
  ! SHL             [ reduce using rule 74 (expression -> expression EQ expression .) ]
  ! SHR             [ reduce using rule 74 (expression -> expression EQ expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 91

    (75) expression -> expression NEQ expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 75 (expression -> expression NEQ expression .)
    &               reduce using rule 75 (expression -> expression NEQ expression .)
    ^               reduce using rule 75 (expression -> expression NEQ expression .)
    AND             reduce using rule 75 (expression -> expression NEQ expression .)
    OR              reduce using rule 75 (expression -> expression NEQ expression .)
    EQ              reduce using rule 75 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 75 (expression -> expression NEQ expression .)
    >               reduce using rule 75 (expression -> expression NEQ expression .)
    <               reduce using rule 75 (expression -> expression NEQ expression .)
    LE              reduce using rule 75 (expression -> expression NEQ expression .)
    GE              reduce using rule 75 (expression -> expression NEQ expression .)
    ;               reduce using rule 75 (expression -> expression NEQ expression .)
    ,               reduce using rule 75 (expression -> expression NEQ expression .)
    )               reduce using rule 75 (expression -> expression NEQ expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    SHL             shift and go to state 57
    SHR             shift and go to state 58

  ! +               [ reduce using rule 75 (expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 75 (expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 75 (expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 75 (expression -> expression NEQ expression .) ]
  ! %               [ reduce using rule 75 (expression -> expression NEQ expression .) ]
  ! SHL             [ reduce using rule 75 (expression -> expression NEQ expression .) ]
  ! SHR             [ reduce using rule 75 (expression -> expression NEQ expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 92

    (76) expression -> expression > expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 76 (expression -> expression > expression .)
    &               reduce using rule 76 (expression -> expression > expression .)
    ^               reduce using rule 76 (expression -> expression > expression .)
    AND             reduce using rule 76 (expression -> expression > expression .)
    OR              reduce using rule 76 (expression -> expression > expression .)
    EQ              reduce using rule 76 (expression -> expression > expression .)
    NEQ             reduce using rule 76 (expression -> expression > expression .)
    >               reduce using rule 76 (expression -> expression > expression .)
    <               reduce using rule 76 (expression -> expression > expression .)
    LE              reduce using rule 76 (expression -> expression > expression .)
    GE              reduce using rule 76 (expression -> expression > expression .)
    ;               reduce using rule 76 (expression -> expression > expression .)
    ,               reduce using rule 76 (expression -> expression > expression .)
    )               reduce using rule 76 (expression -> expression > expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    SHL             shift and go to state 57
    SHR             shift and go to state 58

  ! +               [ reduce using rule 76 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 76 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 76 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 76 (expression -> expression > expression .) ]
  ! %               [ reduce using rule 76 (expression -> expression > expression .) ]
  ! SHL             [ reduce using rule 76 (expression -> expression > expression .) ]
  ! SHR             [ reduce using rule 76 (expression -> expression > expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 93

    (77) expression -> expression < expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 77 (expression -> expression < expression .)
    &               reduce using rule 77 (expression -> expression < expression .)
    ^               reduce using rule 77 (expression -> expression < expression .)
    AND             reduce using rule 77 (expression -> expression < expression .)
    OR              reduce using rule 77 (expression -> expression < expression .)
    EQ              reduce using rule 77 (expression -> expression < expression .)
    NEQ             reduce using rule 77 (expression -> expression < expression .)
    >               reduce using rule 77 (expression -> expression < expression .)
    <               reduce using rule 77 (expression -> expression < expression .)
    LE              reduce using rule 77 (expression -> expression < expression .)
    GE              reduce using rule 77 (expression -> expression < expression .)
    ;               reduce using rule 77 (expression -> expression < expression .)
    ,               reduce using rule 77 (expression -> expression < expression .)
    )               reduce using rule 77 (expression -> expression < expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    SHL             shift and go to state 57
    SHR             shift and go to state 58

  ! +               [ reduce using rule 77 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 77 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 77 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 77 (expression -> expression < expression .) ]
  ! %               [ reduce using rule 77 (expression -> expression < expression .) ]
  ! SHL             [ reduce using rule 77 (expression -> expression < expression .) ]
  ! SHR             [ reduce using rule 77 (expression -> expression < expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 94

    (78) expression -> expression LE expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 78 (expression -> expression LE expression .)
    &               reduce using rule 78 (expression -> expression LE expression .)
    ^               reduce using rule 78 (expression -> expression LE expression .)
    AND             reduce using rule 78 (expression -> expression LE expression .)
    OR              reduce using rule 78 (expression -> expression LE expression .)
    EQ              reduce using rule 78 (expression -> expression LE expression .)
    NEQ             reduce using rule 78 (expression -> expression LE expression .)
    >               reduce using rule 78 (expression -> expression LE expression .)
    <               reduce using rule 78 (expression -> expression LE expression .)
    LE              reduce using rule 78 (expression -> expression LE expression .)
    GE              reduce using rule 78 (expression -> expression LE expression .)
    ;               reduce using rule 78 (expression -> expression LE expression .)
    ,               reduce using rule 78 (expression -> expression LE expression .)
    )               reduce using rule 78 (expression -> expression LE expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    SHL             shift and go to state 57
    SHR             shift and go to state 58

  ! +               [ reduce using rule 78 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 78 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 78 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 78 (expression -> expression LE expression .) ]
  ! %               [ reduce using rule 78 (expression -> expression LE expression .) ]
  ! SHL             [ reduce using rule 78 (expression -> expression LE expression .) ]
  ! SHR             [ reduce using rule 78 (expression -> expression LE expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 95

    (79) expression -> expression GE expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    |               reduce using rule 79 (expression -> expression GE expression .)
    &               reduce using rule 79 (expression -> expression GE expression .)
    ^               reduce using rule 79 (expression -> expression GE expression .)
    AND             reduce using rule 79 (expression -> expression GE expression .)
    OR              reduce using rule 79 (expression -> expression GE expression .)
    EQ              reduce using rule 79 (expression -> expression GE expression .)
    NEQ             reduce using rule 79 (expression -> expression GE expression .)
    >               reduce using rule 79 (expression -> expression GE expression .)
    <               reduce using rule 79 (expression -> expression GE expression .)
    LE              reduce using rule 79 (expression -> expression GE expression .)
    GE              reduce using rule 79 (expression -> expression GE expression .)
    ;               reduce using rule 79 (expression -> expression GE expression .)
    ,               reduce using rule 79 (expression -> expression GE expression .)
    )               reduce using rule 79 (expression -> expression GE expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    SHL             shift and go to state 57
    SHR             shift and go to state 58

  ! +               [ reduce using rule 79 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 79 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 79 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 79 (expression -> expression GE expression .) ]
  ! %               [ reduce using rule 79 (expression -> expression GE expression .) ]
  ! SHL             [ reduce using rule 79 (expression -> expression GE expression .) ]
  ! SHR             [ reduce using rule 79 (expression -> expression GE expression .) ]
  ! |               [ shift and go to state 52 ]
  ! &               [ shift and go to state 53 ]
  ! ^               [ shift and go to state 54 ]
  ! AND             [ shift and go to state 55 ]
  ! OR              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 59 ]
  ! NEQ             [ shift and go to state 60 ]
  ! >               [ shift and go to state 61 ]
  ! <               [ shift and go to state 62 ]
  ! LE              [ shift and go to state 63 ]
  ! GE              [ shift and go to state 64 ]


state 96

    (58) expression -> ( expression ) .

    +               reduce using rule 58 (expression -> ( expression ) .)
    -               reduce using rule 58 (expression -> ( expression ) .)
    *               reduce using rule 58 (expression -> ( expression ) .)
    /               reduce using rule 58 (expression -> ( expression ) .)
    %               reduce using rule 58 (expression -> ( expression ) .)
    |               reduce using rule 58 (expression -> ( expression ) .)
    &               reduce using rule 58 (expression -> ( expression ) .)
    ^               reduce using rule 58 (expression -> ( expression ) .)
    AND             reduce using rule 58 (expression -> ( expression ) .)
    OR              reduce using rule 58 (expression -> ( expression ) .)
    SHL             reduce using rule 58 (expression -> ( expression ) .)
    SHR             reduce using rule 58 (expression -> ( expression ) .)
    EQ              reduce using rule 58 (expression -> ( expression ) .)
    NEQ             reduce using rule 58 (expression -> ( expression ) .)
    >               reduce using rule 58 (expression -> ( expression ) .)
    <               reduce using rule 58 (expression -> ( expression ) .)
    LE              reduce using rule 58 (expression -> ( expression ) .)
    GE              reduce using rule 58 (expression -> ( expression ) .)
    ;               reduce using rule 58 (expression -> ( expression ) .)
    ,               reduce using rule 58 (expression -> ( expression ) .)
    )               reduce using rule 58 (expression -> ( expression ) .)


state 97

    (59) expression -> ( error ) .

    +               reduce using rule 59 (expression -> ( error ) .)
    -               reduce using rule 59 (expression -> ( error ) .)
    *               reduce using rule 59 (expression -> ( error ) .)
    /               reduce using rule 59 (expression -> ( error ) .)
    %               reduce using rule 59 (expression -> ( error ) .)
    |               reduce using rule 59 (expression -> ( error ) .)
    &               reduce using rule 59 (expression -> ( error ) .)
    ^               reduce using rule 59 (expression -> ( error ) .)
    AND             reduce using rule 59 (expression -> ( error ) .)
    OR              reduce using rule 59 (expression -> ( error ) .)
    SHL             reduce using rule 59 (expression -> ( error ) .)
    SHR             reduce using rule 59 (expression -> ( error ) .)
    EQ              reduce using rule 59 (expression -> ( error ) .)
    NEQ             reduce using rule 59 (expression -> ( error ) .)
    >               reduce using rule 59 (expression -> ( error ) .)
    <               reduce using rule 59 (expression -> ( error ) .)
    LE              reduce using rule 59 (expression -> ( error ) .)
    GE              reduce using rule 59 (expression -> ( error ) .)
    ;               reduce using rule 59 (expression -> ( error ) .)
    ,               reduce using rule 59 (expression -> ( error ) .)
    )               reduce using rule 59 (expression -> ( error ) .)


state 98

    (47) compound_instr -> { instructions . }
    (17) instructions -> instructions . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    }               shift and go to state 123
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! }               [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 124
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 99

    (48) compound_instr -> { } .

    TYPE            reduce using rule 48 (compound_instr -> { } .)
    error           reduce using rule 48 (compound_instr -> { } .)
    $end            reduce using rule 48 (compound_instr -> { } .)
    }               reduce using rule 48 (compound_instr -> { } .)
    ID              reduce using rule 48 (compound_instr -> { } .)
    IF              reduce using rule 48 (compound_instr -> { } .)
    WHILE           reduce using rule 48 (compound_instr -> { } .)
    FOR             reduce using rule 48 (compound_instr -> { } .)
    RETURN          reduce using rule 48 (compound_instr -> { } .)
    BREAK           reduce using rule 48 (compound_instr -> { } .)
    CONTINUE        reduce using rule 48 (compound_instr -> { } .)
    {               reduce using rule 48 (compound_instr -> { } .)
    &               reduce using rule 48 (compound_instr -> { } .)
    *               reduce using rule 48 (compound_instr -> { } .)
    (               reduce using rule 48 (compound_instr -> { } .)
    INTEGER         reduce using rule 48 (compound_instr -> { } .)
    FLOAT           reduce using rule 48 (compound_instr -> { } .)
    STRING          reduce using rule 48 (compound_instr -> { } .)
    ELSE            reduce using rule 48 (compound_instr -> { } .)


state 100

    (18) instructions -> instruction .

    }               reduce using rule 18 (instructions -> instruction .)
    ID              reduce using rule 18 (instructions -> instruction .)
    TYPE            reduce using rule 18 (instructions -> instruction .)
    error           reduce using rule 18 (instructions -> instruction .)
    IF              reduce using rule 18 (instructions -> instruction .)
    WHILE           reduce using rule 18 (instructions -> instruction .)
    FOR             reduce using rule 18 (instructions -> instruction .)
    RETURN          reduce using rule 18 (instructions -> instruction .)
    BREAK           reduce using rule 18 (instructions -> instruction .)
    CONTINUE        reduce using rule 18 (instructions -> instruction .)
    {               reduce using rule 18 (instructions -> instruction .)
    &               reduce using rule 18 (instructions -> instruction .)
    *               reduce using rule 18 (instructions -> instruction .)
    (               reduce using rule 18 (instructions -> instruction .)
    INTEGER         reduce using rule 18 (instructions -> instruction .)
    FLOAT           reduce using rule 18 (instructions -> instruction .)
    STRING          reduce using rule 18 (instructions -> instruction .)


state 101

    (19) instruction -> labeled_instr .

    }               reduce using rule 19 (instruction -> labeled_instr .)
    ID              reduce using rule 19 (instruction -> labeled_instr .)
    TYPE            reduce using rule 19 (instruction -> labeled_instr .)
    error           reduce using rule 19 (instruction -> labeled_instr .)
    IF              reduce using rule 19 (instruction -> labeled_instr .)
    WHILE           reduce using rule 19 (instruction -> labeled_instr .)
    FOR             reduce using rule 19 (instruction -> labeled_instr .)
    RETURN          reduce using rule 19 (instruction -> labeled_instr .)
    BREAK           reduce using rule 19 (instruction -> labeled_instr .)
    CONTINUE        reduce using rule 19 (instruction -> labeled_instr .)
    {               reduce using rule 19 (instruction -> labeled_instr .)
    &               reduce using rule 19 (instruction -> labeled_instr .)
    *               reduce using rule 19 (instruction -> labeled_instr .)
    (               reduce using rule 19 (instruction -> labeled_instr .)
    INTEGER         reduce using rule 19 (instruction -> labeled_instr .)
    FLOAT           reduce using rule 19 (instruction -> labeled_instr .)
    STRING          reduce using rule 19 (instruction -> labeled_instr .)
    ELSE            reduce using rule 19 (instruction -> labeled_instr .)


state 102

    (20) instruction -> assignment . ;

    ;               shift and go to state 125


state 103

    (21) instruction -> declaration .

    }               reduce using rule 21 (instruction -> declaration .)
    ID              reduce using rule 21 (instruction -> declaration .)
    TYPE            reduce using rule 21 (instruction -> declaration .)
    error           reduce using rule 21 (instruction -> declaration .)
    IF              reduce using rule 21 (instruction -> declaration .)
    WHILE           reduce using rule 21 (instruction -> declaration .)
    FOR             reduce using rule 21 (instruction -> declaration .)
    RETURN          reduce using rule 21 (instruction -> declaration .)
    BREAK           reduce using rule 21 (instruction -> declaration .)
    CONTINUE        reduce using rule 21 (instruction -> declaration .)
    {               reduce using rule 21 (instruction -> declaration .)
    &               reduce using rule 21 (instruction -> declaration .)
    *               reduce using rule 21 (instruction -> declaration .)
    (               reduce using rule 21 (instruction -> declaration .)
    INTEGER         reduce using rule 21 (instruction -> declaration .)
    FLOAT           reduce using rule 21 (instruction -> declaration .)
    STRING          reduce using rule 21 (instruction -> declaration .)
    ELSE            reduce using rule 21 (instruction -> declaration .)


state 104

    (22) instruction -> choice_instr .

    }               reduce using rule 22 (instruction -> choice_instr .)
    ID              reduce using rule 22 (instruction -> choice_instr .)
    TYPE            reduce using rule 22 (instruction -> choice_instr .)
    error           reduce using rule 22 (instruction -> choice_instr .)
    IF              reduce using rule 22 (instruction -> choice_instr .)
    WHILE           reduce using rule 22 (instruction -> choice_instr .)
    FOR             reduce using rule 22 (instruction -> choice_instr .)
    RETURN          reduce using rule 22 (instruction -> choice_instr .)
    BREAK           reduce using rule 22 (instruction -> choice_instr .)
    CONTINUE        reduce using rule 22 (instruction -> choice_instr .)
    {               reduce using rule 22 (instruction -> choice_instr .)
    &               reduce using rule 22 (instruction -> choice_instr .)
    *               reduce using rule 22 (instruction -> choice_instr .)
    (               reduce using rule 22 (instruction -> choice_instr .)
    INTEGER         reduce using rule 22 (instruction -> choice_instr .)
    FLOAT           reduce using rule 22 (instruction -> choice_instr .)
    STRING          reduce using rule 22 (instruction -> choice_instr .)
    ELSE            reduce using rule 22 (instruction -> choice_instr .)


state 105

    (23) instruction -> while_instr .

    }               reduce using rule 23 (instruction -> while_instr .)
    ID              reduce using rule 23 (instruction -> while_instr .)
    TYPE            reduce using rule 23 (instruction -> while_instr .)
    error           reduce using rule 23 (instruction -> while_instr .)
    IF              reduce using rule 23 (instruction -> while_instr .)
    WHILE           reduce using rule 23 (instruction -> while_instr .)
    FOR             reduce using rule 23 (instruction -> while_instr .)
    RETURN          reduce using rule 23 (instruction -> while_instr .)
    BREAK           reduce using rule 23 (instruction -> while_instr .)
    CONTINUE        reduce using rule 23 (instruction -> while_instr .)
    {               reduce using rule 23 (instruction -> while_instr .)
    &               reduce using rule 23 (instruction -> while_instr .)
    *               reduce using rule 23 (instruction -> while_instr .)
    (               reduce using rule 23 (instruction -> while_instr .)
    INTEGER         reduce using rule 23 (instruction -> while_instr .)
    FLOAT           reduce using rule 23 (instruction -> while_instr .)
    STRING          reduce using rule 23 (instruction -> while_instr .)
    ELSE            reduce using rule 23 (instruction -> while_instr .)


state 106

    (24) instruction -> for_instr .

    }               reduce using rule 24 (instruction -> for_instr .)
    ID              reduce using rule 24 (instruction -> for_instr .)
    TYPE            reduce using rule 24 (instruction -> for_instr .)
    error           reduce using rule 24 (instruction -> for_instr .)
    IF              reduce using rule 24 (instruction -> for_instr .)
    WHILE           reduce using rule 24 (instruction -> for_instr .)
    FOR             reduce using rule 24 (instruction -> for_instr .)
    RETURN          reduce using rule 24 (instruction -> for_instr .)
    BREAK           reduce using rule 24 (instruction -> for_instr .)
    CONTINUE        reduce using rule 24 (instruction -> for_instr .)
    {               reduce using rule 24 (instruction -> for_instr .)
    &               reduce using rule 24 (instruction -> for_instr .)
    *               reduce using rule 24 (instruction -> for_instr .)
    (               reduce using rule 24 (instruction -> for_instr .)
    INTEGER         reduce using rule 24 (instruction -> for_instr .)
    FLOAT           reduce using rule 24 (instruction -> for_instr .)
    STRING          reduce using rule 24 (instruction -> for_instr .)
    ELSE            reduce using rule 24 (instruction -> for_instr .)


state 107

    (25) instruction -> return_instr .

    }               reduce using rule 25 (instruction -> return_instr .)
    ID              reduce using rule 25 (instruction -> return_instr .)
    TYPE            reduce using rule 25 (instruction -> return_instr .)
    error           reduce using rule 25 (instruction -> return_instr .)
    IF              reduce using rule 25 (instruction -> return_instr .)
    WHILE           reduce using rule 25 (instruction -> return_instr .)
    FOR             reduce using rule 25 (instruction -> return_instr .)
    RETURN          reduce using rule 25 (instruction -> return_instr .)
    BREAK           reduce using rule 25 (instruction -> return_instr .)
    CONTINUE        reduce using rule 25 (instruction -> return_instr .)
    {               reduce using rule 25 (instruction -> return_instr .)
    &               reduce using rule 25 (instruction -> return_instr .)
    *               reduce using rule 25 (instruction -> return_instr .)
    (               reduce using rule 25 (instruction -> return_instr .)
    INTEGER         reduce using rule 25 (instruction -> return_instr .)
    FLOAT           reduce using rule 25 (instruction -> return_instr .)
    STRING          reduce using rule 25 (instruction -> return_instr .)
    ELSE            reduce using rule 25 (instruction -> return_instr .)


state 108

    (26) instruction -> break_instr .

    }               reduce using rule 26 (instruction -> break_instr .)
    ID              reduce using rule 26 (instruction -> break_instr .)
    TYPE            reduce using rule 26 (instruction -> break_instr .)
    error           reduce using rule 26 (instruction -> break_instr .)
    IF              reduce using rule 26 (instruction -> break_instr .)
    WHILE           reduce using rule 26 (instruction -> break_instr .)
    FOR             reduce using rule 26 (instruction -> break_instr .)
    RETURN          reduce using rule 26 (instruction -> break_instr .)
    BREAK           reduce using rule 26 (instruction -> break_instr .)
    CONTINUE        reduce using rule 26 (instruction -> break_instr .)
    {               reduce using rule 26 (instruction -> break_instr .)
    &               reduce using rule 26 (instruction -> break_instr .)
    *               reduce using rule 26 (instruction -> break_instr .)
    (               reduce using rule 26 (instruction -> break_instr .)
    INTEGER         reduce using rule 26 (instruction -> break_instr .)
    FLOAT           reduce using rule 26 (instruction -> break_instr .)
    STRING          reduce using rule 26 (instruction -> break_instr .)
    ELSE            reduce using rule 26 (instruction -> break_instr .)


state 109

    (27) instruction -> continue_instr .

    }               reduce using rule 27 (instruction -> continue_instr .)
    ID              reduce using rule 27 (instruction -> continue_instr .)
    TYPE            reduce using rule 27 (instruction -> continue_instr .)
    error           reduce using rule 27 (instruction -> continue_instr .)
    IF              reduce using rule 27 (instruction -> continue_instr .)
    WHILE           reduce using rule 27 (instruction -> continue_instr .)
    FOR             reduce using rule 27 (instruction -> continue_instr .)
    RETURN          reduce using rule 27 (instruction -> continue_instr .)
    BREAK           reduce using rule 27 (instruction -> continue_instr .)
    CONTINUE        reduce using rule 27 (instruction -> continue_instr .)
    {               reduce using rule 27 (instruction -> continue_instr .)
    &               reduce using rule 27 (instruction -> continue_instr .)
    *               reduce using rule 27 (instruction -> continue_instr .)
    (               reduce using rule 27 (instruction -> continue_instr .)
    INTEGER         reduce using rule 27 (instruction -> continue_instr .)
    FLOAT           reduce using rule 27 (instruction -> continue_instr .)
    STRING          reduce using rule 27 (instruction -> continue_instr .)
    ELSE            reduce using rule 27 (instruction -> continue_instr .)


state 110

    (28) instruction -> compound_instr .

    }               reduce using rule 28 (instruction -> compound_instr .)
    ID              reduce using rule 28 (instruction -> compound_instr .)
    TYPE            reduce using rule 28 (instruction -> compound_instr .)
    error           reduce using rule 28 (instruction -> compound_instr .)
    IF              reduce using rule 28 (instruction -> compound_instr .)
    WHILE           reduce using rule 28 (instruction -> compound_instr .)
    FOR             reduce using rule 28 (instruction -> compound_instr .)
    RETURN          reduce using rule 28 (instruction -> compound_instr .)
    BREAK           reduce using rule 28 (instruction -> compound_instr .)
    CONTINUE        reduce using rule 28 (instruction -> compound_instr .)
    {               reduce using rule 28 (instruction -> compound_instr .)
    &               reduce using rule 28 (instruction -> compound_instr .)
    *               reduce using rule 28 (instruction -> compound_instr .)
    (               reduce using rule 28 (instruction -> compound_instr .)
    INTEGER         reduce using rule 28 (instruction -> compound_instr .)
    FLOAT           reduce using rule 28 (instruction -> compound_instr .)
    STRING          reduce using rule 28 (instruction -> compound_instr .)
    ELSE            reduce using rule 28 (instruction -> compound_instr .)


state 111

    (29) instruction -> statement .

    }               reduce using rule 29 (instruction -> statement .)
    ID              reduce using rule 29 (instruction -> statement .)
    TYPE            reduce using rule 29 (instruction -> statement .)
    error           reduce using rule 29 (instruction -> statement .)
    IF              reduce using rule 29 (instruction -> statement .)
    WHILE           reduce using rule 29 (instruction -> statement .)
    FOR             reduce using rule 29 (instruction -> statement .)
    RETURN          reduce using rule 29 (instruction -> statement .)
    BREAK           reduce using rule 29 (instruction -> statement .)
    CONTINUE        reduce using rule 29 (instruction -> statement .)
    {               reduce using rule 29 (instruction -> statement .)
    &               reduce using rule 29 (instruction -> statement .)
    *               reduce using rule 29 (instruction -> statement .)
    (               reduce using rule 29 (instruction -> statement .)
    INTEGER         reduce using rule 29 (instruction -> statement .)
    FLOAT           reduce using rule 29 (instruction -> statement .)
    STRING          reduce using rule 29 (instruction -> statement .)
    ELSE            reduce using rule 29 (instruction -> statement .)


state 112

    (30) instruction -> expression . ;
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ;               shift and go to state 126
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 113

    (32) labeled_instr -> ID . : instruction
    (33) assignment -> ID . = expression
    (34) assignment -> ID . array = expression
    (35) assignment -> ID . = error ;
    (31) statement -> ID . ( expr_list_or_empty ) ;
    (54) expression -> ID .
    (57) expression -> ID . array
    (60) expression -> ID . ( expr_list_or_empty )
    (61) expression -> ID . ( error )
    (3) array -> . [ INTEGER ]

    :               shift and go to state 127
    =               shift and go to state 128
    (               shift and go to state 130
    ;               reduce using rule 54 (expression -> ID .)
    +               reduce using rule 54 (expression -> ID .)
    -               reduce using rule 54 (expression -> ID .)
    *               reduce using rule 54 (expression -> ID .)
    /               reduce using rule 54 (expression -> ID .)
    %               reduce using rule 54 (expression -> ID .)
    |               reduce using rule 54 (expression -> ID .)
    &               reduce using rule 54 (expression -> ID .)
    ^               reduce using rule 54 (expression -> ID .)
    AND             reduce using rule 54 (expression -> ID .)
    OR              reduce using rule 54 (expression -> ID .)
    SHL             reduce using rule 54 (expression -> ID .)
    SHR             reduce using rule 54 (expression -> ID .)
    EQ              reduce using rule 54 (expression -> ID .)
    NEQ             reduce using rule 54 (expression -> ID .)
    >               reduce using rule 54 (expression -> ID .)
    <               reduce using rule 54 (expression -> ID .)
    LE              reduce using rule 54 (expression -> ID .)
    GE              reduce using rule 54 (expression -> ID .)
    [               shift and go to state 23

    array                          shift and go to state 129

state 114

    (36) choice_instr -> IF . ( condition ) instruction
    (37) choice_instr -> IF . ( condition ) instruction ELSE instruction
    (38) choice_instr -> IF . ( error ) instruction
    (39) choice_instr -> IF . ( error ) instruction ELSE instruction

    (               shift and go to state 131


state 115

    (40) while_instr -> WHILE . ( condition ) instruction
    (43) while_instr -> WHILE . ( error ) instruction

    (               shift and go to state 132


state 116

    (41) for_instr -> FOR . ( instruction expression ; assignment ) instruction
    (42) for_instr -> FOR . ( error ) instruction

    (               shift and go to state 133


state 117

    (44) return_instr -> RETURN . expression ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 134
    const                          shift and go to state 33

state 118

    (46) break_instr -> BREAK . ;

    ;               shift and go to state 135


state 119

    (45) continue_instr -> CONTINUE . ;

    ;               shift and go to state 136


state 120

    (60) expression -> ID ( expr_list_or_empty ) .

    +               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    -               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    *               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    /               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    %               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    |               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    &               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    ^               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    AND             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    OR              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    SHL             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    SHR             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    EQ              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    NEQ             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    >               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    <               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    LE              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    GE              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    ;               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    ,               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    )               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)


state 121

    (61) expression -> ID ( error ) .

    +               reduce using rule 61 (expression -> ID ( error ) .)
    -               reduce using rule 61 (expression -> ID ( error ) .)
    *               reduce using rule 61 (expression -> ID ( error ) .)
    /               reduce using rule 61 (expression -> ID ( error ) .)
    %               reduce using rule 61 (expression -> ID ( error ) .)
    |               reduce using rule 61 (expression -> ID ( error ) .)
    &               reduce using rule 61 (expression -> ID ( error ) .)
    ^               reduce using rule 61 (expression -> ID ( error ) .)
    AND             reduce using rule 61 (expression -> ID ( error ) .)
    OR              reduce using rule 61 (expression -> ID ( error ) .)
    SHL             reduce using rule 61 (expression -> ID ( error ) .)
    SHR             reduce using rule 61 (expression -> ID ( error ) .)
    EQ              reduce using rule 61 (expression -> ID ( error ) .)
    NEQ             reduce using rule 61 (expression -> ID ( error ) .)
    >               reduce using rule 61 (expression -> ID ( error ) .)
    <               reduce using rule 61 (expression -> ID ( error ) .)
    LE              reduce using rule 61 (expression -> ID ( error ) .)
    GE              reduce using rule 61 (expression -> ID ( error ) .)
    ;               reduce using rule 61 (expression -> ID ( error ) .)
    ,               reduce using rule 61 (expression -> ID ( error ) .)
    )               reduce using rule 61 (expression -> ID ( error ) .)


state 122

    (82) expr_list -> expr_list , . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 137
    const                          shift and go to state 33

state 123

    (47) compound_instr -> { instructions } .

    TYPE            reduce using rule 47 (compound_instr -> { instructions } .)
    error           reduce using rule 47 (compound_instr -> { instructions } .)
    $end            reduce using rule 47 (compound_instr -> { instructions } .)
    }               reduce using rule 47 (compound_instr -> { instructions } .)
    ID              reduce using rule 47 (compound_instr -> { instructions } .)
    IF              reduce using rule 47 (compound_instr -> { instructions } .)
    WHILE           reduce using rule 47 (compound_instr -> { instructions } .)
    FOR             reduce using rule 47 (compound_instr -> { instructions } .)
    RETURN          reduce using rule 47 (compound_instr -> { instructions } .)
    BREAK           reduce using rule 47 (compound_instr -> { instructions } .)
    CONTINUE        reduce using rule 47 (compound_instr -> { instructions } .)
    {               reduce using rule 47 (compound_instr -> { instructions } .)
    &               reduce using rule 47 (compound_instr -> { instructions } .)
    *               reduce using rule 47 (compound_instr -> { instructions } .)
    (               reduce using rule 47 (compound_instr -> { instructions } .)
    INTEGER         reduce using rule 47 (compound_instr -> { instructions } .)
    FLOAT           reduce using rule 47 (compound_instr -> { instructions } .)
    STRING          reduce using rule 47 (compound_instr -> { instructions } .)
    ELSE            reduce using rule 47 (compound_instr -> { instructions } .)


state 124

    (17) instructions -> instructions instruction .

    }               reduce using rule 17 (instructions -> instructions instruction .)
    ID              reduce using rule 17 (instructions -> instructions instruction .)
    TYPE            reduce using rule 17 (instructions -> instructions instruction .)
    error           reduce using rule 17 (instructions -> instructions instruction .)
    IF              reduce using rule 17 (instructions -> instructions instruction .)
    WHILE           reduce using rule 17 (instructions -> instructions instruction .)
    FOR             reduce using rule 17 (instructions -> instructions instruction .)
    RETURN          reduce using rule 17 (instructions -> instructions instruction .)
    BREAK           reduce using rule 17 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 17 (instructions -> instructions instruction .)
    {               reduce using rule 17 (instructions -> instructions instruction .)
    &               reduce using rule 17 (instructions -> instructions instruction .)
    *               reduce using rule 17 (instructions -> instructions instruction .)
    (               reduce using rule 17 (instructions -> instructions instruction .)
    INTEGER         reduce using rule 17 (instructions -> instructions instruction .)
    FLOAT           reduce using rule 17 (instructions -> instructions instruction .)
    STRING          reduce using rule 17 (instructions -> instructions instruction .)


state 125

    (20) instruction -> assignment ; .

    }               reduce using rule 20 (instruction -> assignment ; .)
    ID              reduce using rule 20 (instruction -> assignment ; .)
    TYPE            reduce using rule 20 (instruction -> assignment ; .)
    error           reduce using rule 20 (instruction -> assignment ; .)
    IF              reduce using rule 20 (instruction -> assignment ; .)
    WHILE           reduce using rule 20 (instruction -> assignment ; .)
    FOR             reduce using rule 20 (instruction -> assignment ; .)
    RETURN          reduce using rule 20 (instruction -> assignment ; .)
    BREAK           reduce using rule 20 (instruction -> assignment ; .)
    CONTINUE        reduce using rule 20 (instruction -> assignment ; .)
    {               reduce using rule 20 (instruction -> assignment ; .)
    &               reduce using rule 20 (instruction -> assignment ; .)
    *               reduce using rule 20 (instruction -> assignment ; .)
    (               reduce using rule 20 (instruction -> assignment ; .)
    INTEGER         reduce using rule 20 (instruction -> assignment ; .)
    FLOAT           reduce using rule 20 (instruction -> assignment ; .)
    STRING          reduce using rule 20 (instruction -> assignment ; .)
    ELSE            reduce using rule 20 (instruction -> assignment ; .)


state 126

    (30) instruction -> expression ; .

    }               reduce using rule 30 (instruction -> expression ; .)
    ID              reduce using rule 30 (instruction -> expression ; .)
    TYPE            reduce using rule 30 (instruction -> expression ; .)
    error           reduce using rule 30 (instruction -> expression ; .)
    IF              reduce using rule 30 (instruction -> expression ; .)
    WHILE           reduce using rule 30 (instruction -> expression ; .)
    FOR             reduce using rule 30 (instruction -> expression ; .)
    RETURN          reduce using rule 30 (instruction -> expression ; .)
    BREAK           reduce using rule 30 (instruction -> expression ; .)
    CONTINUE        reduce using rule 30 (instruction -> expression ; .)
    {               reduce using rule 30 (instruction -> expression ; .)
    &               reduce using rule 30 (instruction -> expression ; .)
    *               reduce using rule 30 (instruction -> expression ; .)
    (               reduce using rule 30 (instruction -> expression ; .)
    INTEGER         reduce using rule 30 (instruction -> expression ; .)
    FLOAT           reduce using rule 30 (instruction -> expression ; .)
    STRING          reduce using rule 30 (instruction -> expression ; .)
    ELSE            reduce using rule 30 (instruction -> expression ; .)


state 127

    (32) labeled_instr -> ID : . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 138
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 128

    (33) assignment -> ID = . expression
    (35) assignment -> ID = . error ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    error           shift and go to state 140
    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 139
    const                          shift and go to state 33

state 129

    (34) assignment -> ID array . = expression
    (57) expression -> ID array .

    =               shift and go to state 141
    ;               reduce using rule 57 (expression -> ID array .)
    +               reduce using rule 57 (expression -> ID array .)
    -               reduce using rule 57 (expression -> ID array .)
    *               reduce using rule 57 (expression -> ID array .)
    /               reduce using rule 57 (expression -> ID array .)
    %               reduce using rule 57 (expression -> ID array .)
    |               reduce using rule 57 (expression -> ID array .)
    &               reduce using rule 57 (expression -> ID array .)
    ^               reduce using rule 57 (expression -> ID array .)
    AND             reduce using rule 57 (expression -> ID array .)
    OR              reduce using rule 57 (expression -> ID array .)
    SHL             reduce using rule 57 (expression -> ID array .)
    SHR             reduce using rule 57 (expression -> ID array .)
    EQ              reduce using rule 57 (expression -> ID array .)
    NEQ             reduce using rule 57 (expression -> ID array .)
    >               reduce using rule 57 (expression -> ID array .)
    <               reduce using rule 57 (expression -> ID array .)
    LE              reduce using rule 57 (expression -> ID array .)
    GE              reduce using rule 57 (expression -> ID array .)


state 130

    (31) statement -> ID ( . expr_list_or_empty ) ;
    (60) expression -> ID ( . expr_list_or_empty )
    (61) expression -> ID ( . error )
    (80) expr_list_or_empty -> . expr_list
    (81) expr_list_or_empty -> .
    (82) expr_list -> . expr_list , expression
    (83) expr_list -> . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    error           shift and go to state 75
    )               reduce using rule 81 (expr_list_or_empty -> .)
    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expr_list_or_empty             shift and go to state 142
    expr_list                      shift and go to state 76
    expression                     shift and go to state 77
    const                          shift and go to state 33

state 131

    (36) choice_instr -> IF ( . condition ) instruction
    (37) choice_instr -> IF ( . condition ) instruction ELSE instruction
    (38) choice_instr -> IF ( . error ) instruction
    (39) choice_instr -> IF ( . error ) instruction ELSE instruction
    (49) condition -> . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    error           shift and go to state 144
    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    condition                      shift and go to state 143
    expression                     shift and go to state 145
    const                          shift and go to state 33

state 132

    (40) while_instr -> WHILE ( . condition ) instruction
    (43) while_instr -> WHILE ( . error ) instruction
    (49) condition -> . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    error           shift and go to state 147
    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    condition                      shift and go to state 146
    expression                     shift and go to state 145
    const                          shift and go to state 33

state 133

    (41) for_instr -> FOR ( . instruction expression ; assignment ) instruction
    (42) for_instr -> FOR ( . error ) instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    error           shift and go to state 149
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 148
    expression                     shift and go to state 112
    assignment                     shift and go to state 102
    labeled_instr                  shift and go to state 101
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 134

    (44) return_instr -> RETURN expression . ;
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ;               shift and go to state 150
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 135

    (46) break_instr -> BREAK ; .

    }               reduce using rule 46 (break_instr -> BREAK ; .)
    ID              reduce using rule 46 (break_instr -> BREAK ; .)
    TYPE            reduce using rule 46 (break_instr -> BREAK ; .)
    error           reduce using rule 46 (break_instr -> BREAK ; .)
    IF              reduce using rule 46 (break_instr -> BREAK ; .)
    WHILE           reduce using rule 46 (break_instr -> BREAK ; .)
    FOR             reduce using rule 46 (break_instr -> BREAK ; .)
    RETURN          reduce using rule 46 (break_instr -> BREAK ; .)
    BREAK           reduce using rule 46 (break_instr -> BREAK ; .)
    CONTINUE        reduce using rule 46 (break_instr -> BREAK ; .)
    {               reduce using rule 46 (break_instr -> BREAK ; .)
    &               reduce using rule 46 (break_instr -> BREAK ; .)
    *               reduce using rule 46 (break_instr -> BREAK ; .)
    (               reduce using rule 46 (break_instr -> BREAK ; .)
    INTEGER         reduce using rule 46 (break_instr -> BREAK ; .)
    FLOAT           reduce using rule 46 (break_instr -> BREAK ; .)
    STRING          reduce using rule 46 (break_instr -> BREAK ; .)
    ELSE            reduce using rule 46 (break_instr -> BREAK ; .)


state 136

    (45) continue_instr -> CONTINUE ; .

    }               reduce using rule 45 (continue_instr -> CONTINUE ; .)
    ID              reduce using rule 45 (continue_instr -> CONTINUE ; .)
    TYPE            reduce using rule 45 (continue_instr -> CONTINUE ; .)
    error           reduce using rule 45 (continue_instr -> CONTINUE ; .)
    IF              reduce using rule 45 (continue_instr -> CONTINUE ; .)
    WHILE           reduce using rule 45 (continue_instr -> CONTINUE ; .)
    FOR             reduce using rule 45 (continue_instr -> CONTINUE ; .)
    RETURN          reduce using rule 45 (continue_instr -> CONTINUE ; .)
    BREAK           reduce using rule 45 (continue_instr -> CONTINUE ; .)
    CONTINUE        reduce using rule 45 (continue_instr -> CONTINUE ; .)
    {               reduce using rule 45 (continue_instr -> CONTINUE ; .)
    &               reduce using rule 45 (continue_instr -> CONTINUE ; .)
    *               reduce using rule 45 (continue_instr -> CONTINUE ; .)
    (               reduce using rule 45 (continue_instr -> CONTINUE ; .)
    INTEGER         reduce using rule 45 (continue_instr -> CONTINUE ; .)
    FLOAT           reduce using rule 45 (continue_instr -> CONTINUE ; .)
    STRING          reduce using rule 45 (continue_instr -> CONTINUE ; .)
    ELSE            reduce using rule 45 (continue_instr -> CONTINUE ; .)


state 137

    (82) expr_list -> expr_list , expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ,               reduce using rule 82 (expr_list -> expr_list , expression .)
    )               reduce using rule 82 (expr_list -> expr_list , expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 138

    (32) labeled_instr -> ID : instruction .

    }               reduce using rule 32 (labeled_instr -> ID : instruction .)
    ID              reduce using rule 32 (labeled_instr -> ID : instruction .)
    TYPE            reduce using rule 32 (labeled_instr -> ID : instruction .)
    error           reduce using rule 32 (labeled_instr -> ID : instruction .)
    IF              reduce using rule 32 (labeled_instr -> ID : instruction .)
    WHILE           reduce using rule 32 (labeled_instr -> ID : instruction .)
    FOR             reduce using rule 32 (labeled_instr -> ID : instruction .)
    RETURN          reduce using rule 32 (labeled_instr -> ID : instruction .)
    BREAK           reduce using rule 32 (labeled_instr -> ID : instruction .)
    CONTINUE        reduce using rule 32 (labeled_instr -> ID : instruction .)
    {               reduce using rule 32 (labeled_instr -> ID : instruction .)
    &               reduce using rule 32 (labeled_instr -> ID : instruction .)
    *               reduce using rule 32 (labeled_instr -> ID : instruction .)
    (               reduce using rule 32 (labeled_instr -> ID : instruction .)
    INTEGER         reduce using rule 32 (labeled_instr -> ID : instruction .)
    FLOAT           reduce using rule 32 (labeled_instr -> ID : instruction .)
    STRING          reduce using rule 32 (labeled_instr -> ID : instruction .)
    ELSE            reduce using rule 32 (labeled_instr -> ID : instruction .)


state 139

    (33) assignment -> ID = expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ;               reduce using rule 33 (assignment -> ID = expression .)
    )               reduce using rule 33 (assignment -> ID = expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 140

    (35) assignment -> ID = error . ;

    ;               shift and go to state 151


state 141

    (34) assignment -> ID array = . expression
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 152
    const                          shift and go to state 33

state 142

    (31) statement -> ID ( expr_list_or_empty . ) ;
    (60) expression -> ID ( expr_list_or_empty . )

    )               shift and go to state 153


state 143

    (36) choice_instr -> IF ( condition . ) instruction
    (37) choice_instr -> IF ( condition . ) instruction ELSE instruction

    )               shift and go to state 154


state 144

    (38) choice_instr -> IF ( error . ) instruction
    (39) choice_instr -> IF ( error . ) instruction ELSE instruction

    )               shift and go to state 155


state 145

    (49) condition -> expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    )               reduce using rule 49 (condition -> expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 146

    (40) while_instr -> WHILE ( condition . ) instruction

    )               shift and go to state 156


state 147

    (43) while_instr -> WHILE ( error . ) instruction

    )               shift and go to state 157


state 148

    (41) for_instr -> FOR ( instruction . expression ; assignment ) instruction
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING

    ID              shift and go to state 31
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

    expression                     shift and go to state 158
    const                          shift and go to state 33

state 149

    (42) for_instr -> FOR ( error . ) instruction
    (9) declaration -> error . ;

    )               shift and go to state 159
    ;               shift and go to state 16


state 150

    (44) return_instr -> RETURN expression ; .

    }               reduce using rule 44 (return_instr -> RETURN expression ; .)
    ID              reduce using rule 44 (return_instr -> RETURN expression ; .)
    TYPE            reduce using rule 44 (return_instr -> RETURN expression ; .)
    error           reduce using rule 44 (return_instr -> RETURN expression ; .)
    IF              reduce using rule 44 (return_instr -> RETURN expression ; .)
    WHILE           reduce using rule 44 (return_instr -> RETURN expression ; .)
    FOR             reduce using rule 44 (return_instr -> RETURN expression ; .)
    RETURN          reduce using rule 44 (return_instr -> RETURN expression ; .)
    BREAK           reduce using rule 44 (return_instr -> RETURN expression ; .)
    CONTINUE        reduce using rule 44 (return_instr -> RETURN expression ; .)
    {               reduce using rule 44 (return_instr -> RETURN expression ; .)
    &               reduce using rule 44 (return_instr -> RETURN expression ; .)
    *               reduce using rule 44 (return_instr -> RETURN expression ; .)
    (               reduce using rule 44 (return_instr -> RETURN expression ; .)
    INTEGER         reduce using rule 44 (return_instr -> RETURN expression ; .)
    FLOAT           reduce using rule 44 (return_instr -> RETURN expression ; .)
    STRING          reduce using rule 44 (return_instr -> RETURN expression ; .)
    ELSE            reduce using rule 44 (return_instr -> RETURN expression ; .)


state 151

    (35) assignment -> ID = error ; .

    ;               reduce using rule 35 (assignment -> ID = error ; .)
    )               reduce using rule 35 (assignment -> ID = error ; .)


state 152

    (34) assignment -> ID array = expression .
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ;               reduce using rule 34 (assignment -> ID array = expression .)
    )               reduce using rule 34 (assignment -> ID array = expression .)
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 153

    (31) statement -> ID ( expr_list_or_empty ) . ;
    (60) expression -> ID ( expr_list_or_empty ) .

  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 160
    +               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    -               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    *               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    /               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    %               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    |               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    &               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    ^               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    AND             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    OR              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    SHL             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    SHR             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    EQ              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    NEQ             reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    >               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    <               reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    LE              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)
    GE              reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .)

  ! ;               [ reduce using rule 60 (expression -> ID ( expr_list_or_empty ) .) ]


state 154

    (36) choice_instr -> IF ( condition ) . instruction
    (37) choice_instr -> IF ( condition ) . instruction ELSE instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 161
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 155

    (38) choice_instr -> IF ( error ) . instruction
    (39) choice_instr -> IF ( error ) . instruction ELSE instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 162
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 156

    (40) while_instr -> WHILE ( condition ) . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 163
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 157

    (43) while_instr -> WHILE ( error ) . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 164
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 158

    (41) for_instr -> FOR ( instruction expression . ; assignment ) instruction
    (62) expression -> expression . + expression
    (63) expression -> expression . - expression
    (64) expression -> expression . * expression
    (65) expression -> expression . / expression
    (66) expression -> expression . % expression
    (67) expression -> expression . | expression
    (68) expression -> expression . & expression
    (69) expression -> expression . ^ expression
    (70) expression -> expression . AND expression
    (71) expression -> expression . OR expression
    (72) expression -> expression . SHL expression
    (73) expression -> expression . SHR expression
    (74) expression -> expression . EQ expression
    (75) expression -> expression . NEQ expression
    (76) expression -> expression . > expression
    (77) expression -> expression . < expression
    (78) expression -> expression . LE expression
    (79) expression -> expression . GE expression

    ;               shift and go to state 165
    +               shift and go to state 47
    -               shift and go to state 48
    *               shift and go to state 49
    /               shift and go to state 50
    %               shift and go to state 51
    |               shift and go to state 52
    &               shift and go to state 53
    ^               shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56
    SHL             shift and go to state 57
    SHR             shift and go to state 58
    EQ              shift and go to state 59
    NEQ             shift and go to state 60
    >               shift and go to state 61
    <               shift and go to state 62
    LE              shift and go to state 63
    GE              shift and go to state 64


state 159

    (42) for_instr -> FOR ( error ) . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 166
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 160

    (31) statement -> ID ( expr_list_or_empty ) ; .

    }               reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    ID              reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    TYPE            reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    error           reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    IF              reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    WHILE           reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    FOR             reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    RETURN          reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    BREAK           reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    CONTINUE        reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    {               reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    &               reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    *               reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    (               reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    INTEGER         reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    FLOAT           reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    STRING          reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)
    ELSE            reduce using rule 31 (statement -> ID ( expr_list_or_empty ) ; .)


state 161

    (36) choice_instr -> IF ( condition ) instruction .
    (37) choice_instr -> IF ( condition ) instruction . ELSE instruction

    }               reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    ID              reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    TYPE            reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    error           reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    IF              reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    WHILE           reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    FOR             reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    RETURN          reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    BREAK           reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    CONTINUE        reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    {               reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    &               reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    *               reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    (               reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    INTEGER         reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    FLOAT           reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    STRING          reduce using rule 36 (choice_instr -> IF ( condition ) instruction .)
    ELSE            shift and go to state 167

  ! ELSE            [ reduce using rule 36 (choice_instr -> IF ( condition ) instruction .) ]


state 162

    (38) choice_instr -> IF ( error ) instruction .
    (39) choice_instr -> IF ( error ) instruction . ELSE instruction

    }               reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    ID              reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    TYPE            reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    error           reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    IF              reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    WHILE           reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    FOR             reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    RETURN          reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    BREAK           reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    {               reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    &               reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    *               reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    (               reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    INTEGER         reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    FLOAT           reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    STRING          reduce using rule 38 (choice_instr -> IF ( error ) instruction .)
    ELSE            shift and go to state 168

  ! ELSE            [ reduce using rule 38 (choice_instr -> IF ( error ) instruction .) ]


state 163

    (40) while_instr -> WHILE ( condition ) instruction .

    }               reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    ID              reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    TYPE            reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    error           reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    IF              reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    WHILE           reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    FOR             reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    RETURN          reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    BREAK           reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    CONTINUE        reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    {               reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    &               reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    *               reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    (               reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    INTEGER         reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    FLOAT           reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    STRING          reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)
    ELSE            reduce using rule 40 (while_instr -> WHILE ( condition ) instruction .)


state 164

    (43) while_instr -> WHILE ( error ) instruction .

    }               reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    ID              reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    TYPE            reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    error           reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    IF              reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    FOR             reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    {               reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    &               reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    *               reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    (               reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    INTEGER         reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    FLOAT           reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    STRING          reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 43 (while_instr -> WHILE ( error ) instruction .)


state 165

    (41) for_instr -> FOR ( instruction expression ; . assignment ) instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;

    ID              shift and go to state 170

    assignment                     shift and go to state 169

state 166

    (42) for_instr -> FOR ( error ) instruction .

    }               reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    ID              reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    TYPE            reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    error           reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    IF              reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    WHILE           reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    FOR             reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    RETURN          reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    BREAK           reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    CONTINUE        reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    {               reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    &               reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    *               reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    (               reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    INTEGER         reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    FLOAT           reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    STRING          reduce using rule 42 (for_instr -> FOR ( error ) instruction .)
    ELSE            reduce using rule 42 (for_instr -> FOR ( error ) instruction .)


state 167

    (37) choice_instr -> IF ( condition ) instruction ELSE . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 171
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 168

    (39) choice_instr -> IF ( error ) instruction ELSE . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 172
    labeled_instr                  shift and go to state 101
    assignment                     shift and go to state 102
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    expression                     shift and go to state 112
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 169

    (41) for_instr -> FOR ( instruction expression ; assignment . ) instruction

    )               shift and go to state 173


state 170

    (33) assignment -> ID . = expression
    (34) assignment -> ID . array = expression
    (35) assignment -> ID . = error ;
    (3) array -> . [ INTEGER ]

    =               shift and go to state 128
    [               shift and go to state 23

    array                          shift and go to state 174

state 171

    (37) choice_instr -> IF ( condition ) instruction ELSE instruction .

    }               reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ID              reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    TYPE            reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    error           reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    IF              reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    WHILE           reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    FOR             reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    RETURN          reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    BREAK           reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    {               reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    &               reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    *               reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    (               reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    INTEGER         reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    FLOAT           reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    STRING          reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ELSE            reduce using rule 37 (choice_instr -> IF ( condition ) instruction ELSE instruction .)


state 172

    (39) choice_instr -> IF ( error ) instruction ELSE instruction .

    }               reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    TYPE            reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    error           reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    FOR             reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    {               reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    &               reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    *               reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    (               reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    INTEGER         reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    FLOAT           reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    STRING          reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 39 (choice_instr -> IF ( error ) instruction ELSE instruction .)


state 173

    (41) for_instr -> FOR ( instruction expression ; assignment ) . instruction
    (19) instruction -> . labeled_instr
    (20) instruction -> . assignment ;
    (21) instruction -> . declaration
    (22) instruction -> . choice_instr
    (23) instruction -> . while_instr
    (24) instruction -> . for_instr
    (25) instruction -> . return_instr
    (26) instruction -> . break_instr
    (27) instruction -> . continue_instr
    (28) instruction -> . compound_instr
    (29) instruction -> . statement
    (30) instruction -> . expression ;
    (32) labeled_instr -> . ID : instruction
    (33) assignment -> . ID = expression
    (34) assignment -> . ID array = expression
    (35) assignment -> . ID = error ;
    (7) declaration -> . fundefs
    (8) declaration -> . TYPE inits ;
    (9) declaration -> . error ;
    (36) choice_instr -> . IF ( condition ) instruction
    (37) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (38) choice_instr -> . IF ( error ) instruction
    (39) choice_instr -> . IF ( error ) instruction ELSE instruction
    (40) while_instr -> . WHILE ( condition ) instruction
    (43) while_instr -> . WHILE ( error ) instruction
    (41) for_instr -> . FOR ( instruction expression ; assignment ) instruction
    (42) for_instr -> . FOR ( error ) instruction
    (44) return_instr -> . RETURN expression ;
    (46) break_instr -> . BREAK ;
    (45) continue_instr -> . CONTINUE ;
    (47) compound_instr -> . { instructions }
    (48) compound_instr -> . { }
    (31) statement -> . ID ( expr_list_or_empty ) ;
    (53) expression -> . const
    (54) expression -> . ID
    (55) expression -> . & ID
    (56) expression -> . * ID
    (57) expression -> . ID array
    (58) expression -> . ( expression )
    (59) expression -> . ( error )
    (60) expression -> . ID ( expr_list_or_empty )
    (61) expression -> . ID ( error )
    (62) expression -> . expression + expression
    (63) expression -> . expression - expression
    (64) expression -> . expression * expression
    (65) expression -> . expression / expression
    (66) expression -> . expression % expression
    (67) expression -> . expression | expression
    (68) expression -> . expression & expression
    (69) expression -> . expression ^ expression
    (70) expression -> . expression AND expression
    (71) expression -> . expression OR expression
    (72) expression -> . expression SHL expression
    (73) expression -> . expression SHR expression
    (74) expression -> . expression EQ expression
    (75) expression -> . expression NEQ expression
    (76) expression -> . expression > expression
    (77) expression -> . expression < expression
    (78) expression -> . expression LE expression
    (79) expression -> . expression GE expression
    (84) fundefs -> . fundefs fundef
    (85) fundefs -> . fundef
    (86) fundefs -> .
    (50) const -> . INTEGER
    (51) const -> . FLOAT
    (52) const -> . STRING
    (87) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr

  ! shift/reduce conflict for TYPE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for error resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for & resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
    ID              shift and go to state 113
    TYPE            shift and go to state 6
    error           shift and go to state 7
    IF              shift and go to state 114
    WHILE           shift and go to state 115
    FOR             shift and go to state 116
    RETURN          shift and go to state 117
    BREAK           shift and go to state 118
    CONTINUE        shift and go to state 119
    {               shift and go to state 72
    &               shift and go to state 34
    *               shift and go to state 35
    (               shift and go to state 36
    }               reduce using rule 86 (fundefs -> .)
    ELSE            reduce using rule 86 (fundefs -> .)
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    STRING          shift and go to state 39

  ! TYPE            [ reduce using rule 86 (fundefs -> .) ]
  ! ID              [ reduce using rule 86 (fundefs -> .) ]
  ! error           [ reduce using rule 86 (fundefs -> .) ]
  ! IF              [ reduce using rule 86 (fundefs -> .) ]
  ! WHILE           [ reduce using rule 86 (fundefs -> .) ]
  ! FOR             [ reduce using rule 86 (fundefs -> .) ]
  ! RETURN          [ reduce using rule 86 (fundefs -> .) ]
  ! BREAK           [ reduce using rule 86 (fundefs -> .) ]
  ! CONTINUE        [ reduce using rule 86 (fundefs -> .) ]
  ! {               [ reduce using rule 86 (fundefs -> .) ]
  ! &               [ reduce using rule 86 (fundefs -> .) ]
  ! *               [ reduce using rule 86 (fundefs -> .) ]
  ! (               [ reduce using rule 86 (fundefs -> .) ]
  ! INTEGER         [ reduce using rule 86 (fundefs -> .) ]
  ! FLOAT           [ reduce using rule 86 (fundefs -> .) ]
  ! STRING          [ reduce using rule 86 (fundefs -> .) ]

    instruction                    shift and go to state 175
    expression                     shift and go to state 112
    assignment                     shift and go to state 102
    labeled_instr                  shift and go to state 101
    declaration                    shift and go to state 103
    choice_instr                   shift and go to state 104
    while_instr                    shift and go to state 105
    for_instr                      shift and go to state 106
    return_instr                   shift and go to state 107
    break_instr                    shift and go to state 108
    continue_instr                 shift and go to state 109
    compound_instr                 shift and go to state 110
    statement                      shift and go to state 111
    fundefs                        shift and go to state 5
    const                          shift and go to state 33
    fundef                         shift and go to state 8

state 174

    (34) assignment -> ID array . = expression

    =               shift and go to state 141


state 175

    (41) for_instr -> FOR ( instruction expression ; assignment ) instruction .

    }               reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    ID              reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    TYPE            reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    error           reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    IF              reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    WHILE           reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    FOR             reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    RETURN          reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    BREAK           reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    CONTINUE        reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    {               reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    &               reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    *               reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    (               reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    INTEGER         reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    FLOAT           reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    STRING          reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)
    ELSE            reduce using rule 41 (for_instr -> FOR ( instruction expression ; assignment ) instruction .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for error in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for error in state 0 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 3 resolved as shift
WARNING: shift/reduce conflict for error in state 3 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 5 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 72 resolved as shift
WARNING: shift/reduce conflict for } in state 72 resolved as shift
WARNING: shift/reduce conflict for ID in state 72 resolved as shift
WARNING: shift/reduce conflict for error in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 72 resolved as shift
WARNING: shift/reduce conflict for FOR in state 72 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 72 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 72 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 72 resolved as shift
WARNING: shift/reduce conflict for { in state 72 resolved as shift
WARNING: shift/reduce conflict for & in state 72 resolved as shift
WARNING: shift/reduce conflict for * in state 72 resolved as shift
WARNING: shift/reduce conflict for ( in state 72 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 72 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 72 resolved as shift
WARNING: shift/reduce conflict for STRING in state 72 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 98 resolved as shift
WARNING: shift/reduce conflict for } in state 98 resolved as shift
WARNING: shift/reduce conflict for ID in state 98 resolved as shift
WARNING: shift/reduce conflict for error in state 98 resolved as shift
WARNING: shift/reduce conflict for IF in state 98 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 98 resolved as shift
WARNING: shift/reduce conflict for FOR in state 98 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 98 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 98 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 98 resolved as shift
WARNING: shift/reduce conflict for { in state 98 resolved as shift
WARNING: shift/reduce conflict for & in state 98 resolved as shift
WARNING: shift/reduce conflict for * in state 98 resolved as shift
WARNING: shift/reduce conflict for ( in state 98 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 98 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 98 resolved as shift
WARNING: shift/reduce conflict for STRING in state 98 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 127 resolved as shift
WARNING: shift/reduce conflict for ID in state 127 resolved as shift
WARNING: shift/reduce conflict for error in state 127 resolved as shift
WARNING: shift/reduce conflict for IF in state 127 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 127 resolved as shift
WARNING: shift/reduce conflict for FOR in state 127 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 127 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 127 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 127 resolved as shift
WARNING: shift/reduce conflict for { in state 127 resolved as shift
WARNING: shift/reduce conflict for & in state 127 resolved as shift
WARNING: shift/reduce conflict for * in state 127 resolved as shift
WARNING: shift/reduce conflict for ( in state 127 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 127 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 127 resolved as shift
WARNING: shift/reduce conflict for STRING in state 127 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 133 resolved as shift
WARNING: shift/reduce conflict for ID in state 133 resolved as shift
WARNING: shift/reduce conflict for & in state 133 resolved as shift
WARNING: shift/reduce conflict for * in state 133 resolved as shift
WARNING: shift/reduce conflict for ( in state 133 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 133 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 133 resolved as shift
WARNING: shift/reduce conflict for STRING in state 133 resolved as shift
WARNING: shift/reduce conflict for ; in state 153 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 154 resolved as shift
WARNING: shift/reduce conflict for ID in state 154 resolved as shift
WARNING: shift/reduce conflict for error in state 154 resolved as shift
WARNING: shift/reduce conflict for IF in state 154 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 154 resolved as shift
WARNING: shift/reduce conflict for FOR in state 154 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 154 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 154 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 154 resolved as shift
WARNING: shift/reduce conflict for { in state 154 resolved as shift
WARNING: shift/reduce conflict for & in state 154 resolved as shift
WARNING: shift/reduce conflict for * in state 154 resolved as shift
WARNING: shift/reduce conflict for ( in state 154 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 154 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 154 resolved as shift
WARNING: shift/reduce conflict for STRING in state 154 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 155 resolved as shift
WARNING: shift/reduce conflict for ID in state 155 resolved as shift
WARNING: shift/reduce conflict for error in state 155 resolved as shift
WARNING: shift/reduce conflict for IF in state 155 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 155 resolved as shift
WARNING: shift/reduce conflict for FOR in state 155 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 155 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 155 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 155 resolved as shift
WARNING: shift/reduce conflict for { in state 155 resolved as shift
WARNING: shift/reduce conflict for & in state 155 resolved as shift
WARNING: shift/reduce conflict for * in state 155 resolved as shift
WARNING: shift/reduce conflict for ( in state 155 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 155 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 155 resolved as shift
WARNING: shift/reduce conflict for STRING in state 155 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 156 resolved as shift
WARNING: shift/reduce conflict for ID in state 156 resolved as shift
WARNING: shift/reduce conflict for error in state 156 resolved as shift
WARNING: shift/reduce conflict for IF in state 156 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 156 resolved as shift
WARNING: shift/reduce conflict for FOR in state 156 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 156 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 156 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 156 resolved as shift
WARNING: shift/reduce conflict for { in state 156 resolved as shift
WARNING: shift/reduce conflict for & in state 156 resolved as shift
WARNING: shift/reduce conflict for * in state 156 resolved as shift
WARNING: shift/reduce conflict for ( in state 156 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 156 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 156 resolved as shift
WARNING: shift/reduce conflict for STRING in state 156 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for error in state 157 resolved as shift
WARNING: shift/reduce conflict for IF in state 157 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 157 resolved as shift
WARNING: shift/reduce conflict for FOR in state 157 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 157 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 157 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 157 resolved as shift
WARNING: shift/reduce conflict for { in state 157 resolved as shift
WARNING: shift/reduce conflict for & in state 157 resolved as shift
WARNING: shift/reduce conflict for * in state 157 resolved as shift
WARNING: shift/reduce conflict for ( in state 157 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 157 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 157 resolved as shift
WARNING: shift/reduce conflict for STRING in state 157 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for error in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 159 resolved as shift
WARNING: shift/reduce conflict for FOR in state 159 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 159 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 159 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 159 resolved as shift
WARNING: shift/reduce conflict for { in state 159 resolved as shift
WARNING: shift/reduce conflict for & in state 159 resolved as shift
WARNING: shift/reduce conflict for * in state 159 resolved as shift
WARNING: shift/reduce conflict for ( in state 159 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 159 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 159 resolved as shift
WARNING: shift/reduce conflict for STRING in state 159 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for ID in state 167 resolved as shift
WARNING: shift/reduce conflict for error in state 167 resolved as shift
WARNING: shift/reduce conflict for IF in state 167 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 167 resolved as shift
WARNING: shift/reduce conflict for FOR in state 167 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 167 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 167 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 167 resolved as shift
WARNING: shift/reduce conflict for { in state 167 resolved as shift
WARNING: shift/reduce conflict for & in state 167 resolved as shift
WARNING: shift/reduce conflict for * in state 167 resolved as shift
WARNING: shift/reduce conflict for ( in state 167 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 167 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 167 resolved as shift
WARNING: shift/reduce conflict for STRING in state 167 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 168 resolved as shift
WARNING: shift/reduce conflict for ID in state 168 resolved as shift
WARNING: shift/reduce conflict for error in state 168 resolved as shift
WARNING: shift/reduce conflict for IF in state 168 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 168 resolved as shift
WARNING: shift/reduce conflict for FOR in state 168 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 168 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 168 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 168 resolved as shift
WARNING: shift/reduce conflict for { in state 168 resolved as shift
WARNING: shift/reduce conflict for & in state 168 resolved as shift
WARNING: shift/reduce conflict for * in state 168 resolved as shift
WARNING: shift/reduce conflict for ( in state 168 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 168 resolved as shift
WARNING: shift/reduce conflict for STRING in state 168 resolved as shift
WARNING: shift/reduce conflict for TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for ID in state 173 resolved as shift
WARNING: shift/reduce conflict for error in state 173 resolved as shift
WARNING: shift/reduce conflict for IF in state 173 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 173 resolved as shift
WARNING: shift/reduce conflict for FOR in state 173 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 173 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 173 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 173 resolved as shift
WARNING: shift/reduce conflict for { in state 173 resolved as shift
WARNING: shift/reduce conflict for & in state 173 resolved as shift
WARNING: shift/reduce conflict for * in state 173 resolved as shift
WARNING: shift/reduce conflict for ( in state 173 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 173 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 173 resolved as shift
WARNING: shift/reduce conflict for STRING in state 173 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (declarations -> <empty>)
WARNING: rejected rule (fundefs -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 3 resolved using rule (ext_declarations -> declarations)
WARNING: rejected rule (fundefs -> <empty>) in state 3
